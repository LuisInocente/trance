<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Music Loop Maker</title>

  <link rel="icon" href="data:,">

  <style>
    :root{
      --bg:#0f0f0f;
      --card:#1a1a1a;
      --border:#333;
      --text:#e5e5e5;
      --muted:#888;

      --gridBorder:#2a2a2a;
      --cellA:#1a1a1a;
      --cellB:#222;
      --playhead: rgba(255,255,255,.2);

      --t1:hsl(10 70% 45%);
      --t2:hsl(90 55% 40%);
      --t3:hsl(200 65% 45%);
      --t4:hsl(280 60% 50%);
      --t5:hsl(45 75% 45%);
      --t6:hsl(160 55% 40%);
      --t7:hsl(210 70% 50%);
      --t8:hsl(330 60% 50%);

      --noteGrey:#333;
      --noteNat:#444;

      --bassOn:#991b1b;
      --leadOn:#7c3aed;

      --headerH:70px;
      --footerH:40px;
      --gap:10px;

      --loopEmpty:#333;
      --loopArmed:#b45309;
      --loopRecording:#dc2626;
      --loopReady:#16a34a;
      --loopPlaying:#2563eb;
    }

    *{ box-sizing:border-box; }

    /* Scrollbar styling for dark mode */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--card); }
    ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }

    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      overflow-x:hidden;
      overflow-y:auto;
    }

    header{
      height:var(--headerH);
      position:sticky; top:0; z-index:50;
      background:var(--card);
      border-bottom:1px solid var(--border);
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .headerTop{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap:10px;
      align-items:center;
    }

    .topLeft,.topMid,.topRight{ display:flex; align-items:center; gap:10px; }
    .topLeft{ justify-content:flex-start; }
    .topMid{ justify-content:center; }
    .topRight{ justify-content:flex-end; flex-wrap:wrap; }

    .loopSlots{
      display:flex;
      gap:8px;
    }

    .loopSlot{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:2px;
    }

    .loopBtn{
      width:50px;
      height:40px;
      border:2px solid var(--border);
      border-radius:12px;
      background:var(--loopEmpty);
      cursor:pointer;
      font-weight:1000;
      font-size:16px;
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all 0.15s ease;
      position:relative;
      overflow:hidden;
    }

    .loopBtn:hover{ transform:scale(1.05); }

    .loopBtn.armed{
      background:var(--loopArmed);
      border-color:#f59e0b;
      animation:pulse 0.8s ease-in-out infinite;
    }

    .loopBtn.recording{
      background:var(--loopRecording);
      border-color:#ef4444;
      color:#fff;
      animation:pulse 0.5s ease-in-out infinite;
    }

    .loopBtn.ready{
      background:var(--loopReady);
      border-color:#22c55e;
      color:#fff;
    }

    .loopBtn.playing{
      background:var(--loopPlaying);
      border-color:#3b82f6;
      color:#fff;
      box-shadow:0 0 20px rgba(59,130,246,0.5);
    }

    .loopBtn.pending{
      background:#7c3aed;
      border-color:#a855f7;
      color:#fff;
      animation:pulse 0.6s ease-in-out infinite;
    }

    @keyframes pulse{
      0%,100%{ opacity:1; }
      50%{ opacity:0.7; }
    }

    .loopProgress{
      position:absolute;
      bottom:0;
      left:0;
      height:4px;
      background:rgba(255,255,255,0.7);
      width:0%;
      transition:width 0.1s linear;
    }

    .loopStatus{
      font-size:9px;
      font-weight:900;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.3px;
    }

    .loopStatus.armed{ color:#fbbf24; }
    .loopStatus.recording{ color:#f87171; }
    .loopStatus.ready{ color:#4ade80; }
    .loopStatus.playing{ color:#60a5fa; }
    .loopStatus.pending{ color:#c084fc; }

    .loopControlBtn{
      height:32px;
      padding:0 10px;
      border-radius:10px;
      font-size:11px;
      font-weight:900;
      border:1px solid var(--border);
      background:var(--card);
      color:var(--text);
      cursor:pointer;
    }

    .loopControlBtn.stop{ background:#dc2626; color:#fff; border-color:#b91c1c; }
    .loopControlBtn:disabled{ opacity:0.4; cursor:not-allowed; }

    .pill{
      display:flex; align-items:center; gap:10px;
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:var(--card);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{ color:var(--text); font-weight:950; }

    input[type="range"]{ accent-color:#3b82f6; }

    .tempoRange{ width:140px; }

    button{
      border:1px solid var(--border);
      background:var(--card);
      color:var(--text);
      height:40px;
      padding:0 16px;
      border-radius:14px;
      cursor:pointer;
      font-weight:950;
      font-size:15px;
      white-space:nowrap;
      touch-action:manipulation;
    }
    button.primary{ background:#3b82f6; color:#fff; border-color:#2563eb; }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .wrap{
      padding:var(--gap);
      padding-bottom:calc(var(--gap) + var(--footerH));
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    
    .card.drums{ flex:0 0 auto; }
    .card.card-lead{ flex:0 0 auto; }
    .card.card-bass{ flex:0 0 auto; }
    .card.card-mixer{ flex:0 0 auto; }

    .card{
      border:1px solid var(--border);
      border-radius:18px;
      background:var(--card);
      box-shadow:0 10px 28px rgba(0,0,0,.3);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .cardHead{
      padding:8px 10px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between;
      gap:8px;
      flex:0 0 auto;
    }
    .title{
      font-size:14px;
      font-weight:1000;
      letter-spacing:.2px;
    }

    .smallBtn{
      height:34px;
      padding:0 12px;
      border-radius:12px;
      font-size:13px;
      font-weight:900;
    }

    .body{
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
    }

    .drumToolsCompact{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      align-items:center;
      justify-content:flex-end;
    }
    .drumToolsCompact .smallBtn{
      height:28px;
      padding:0 8px;
      font-size:11px;
      border-radius:10px;
    }

    /* Sample bars */
    .samplerBar{
      display:flex;
      gap:4px;
      align-items:center;
      padding:4px 6px;
      border:1px solid var(--border);
      border-radius:12px;
      background:var(--card);
      flex-wrap:wrap;
      flex:0 0 auto;
    }
    .samplerStatus{
      font-size:11px;
      font-weight:950;
      color:var(--muted);
      white-space:nowrap;
      max-width:140px;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .samplerKnob{
      display:flex; align-items:center; gap:6px;
      padding:4px 6px;
      border:1px solid var(--border);
      border-radius:999px;
      background:var(--card);
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
      height:26px;
    }
    .samplerKnob input[type="range"]{ width:60px; }
    #s1PitchVal,#s2PitchVal{ display:inline-block; width:3ch; text-align:center; font-variant-numeric:tabular-nums; }

    /* Drum grid */
    .gridWrap{
      border:1px solid var(--gridBorder);
      border-radius:16px;
      overflow:hidden;
      background:var(--card);
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      touch-action:manipulation;
    }
    .headerRow{
      display:grid;
      grid-template-columns: 200px repeat(16, 1fr);
      border-bottom:1px solid var(--gridBorder);
      background:var(--card);
      flex:0 0 auto;
    }
    .headerCell{
      padding:6px 4px;
      font-size:9px;
      color:var(--muted);
      text-align:center;
      border-left:1px solid var(--gridBorder);
      font-weight:900;
    }
    .headerCell:first-child{
      text-align:left;
      border-left:none;
      padding-left:10px;
    }
    #grid{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      touch-action:manipulation;
    }

    .row{ display:grid; grid-template-columns: 200px repeat(16,1fr); }
    .row+.row{ border-top:1px solid var(--gridBorder); }

    .trackCell{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:4px 8px;
      border-right:1px solid var(--gridBorder);
      background:var(--card);
      min-width:0;
    }
    .trackLeft{
      display:flex;
      align-items:center;
      gap:6px;
      min-width:0;
      flex:1 1 auto;
    }
    .swatch{
      width:10px; height:10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.15);
      flex:0 0 auto;
    }
    .trackText{
      display:flex;
      flex-direction:column;
      min-width:0;
      gap:1px;
      flex:1 1 auto;
    }
    .trackName{
      font-weight:1000;
      font-size:11px;
      color:var(--text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:120px;
      line-height:1.1;
    }
    .fileLabel{
      font-size:9px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:120px;
    }

    /* per-drum volume slider ONLY */
    .trkVol{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      padding:2px 6px;
      border:1px solid var(--border);
      border-radius:999px;
      height:24px;
      background:var(--card);
      touch-action:pan-x;
    }
    .trkVol input[type="range"]{
      width:60px;
      touch-action:pan-x;
    }

    .cell{
      height:28px;
      border-left:1px solid var(--gridBorder);
      display:flex; align-items:center; justify-content:center;
      background:var(--cellA);
      cursor:pointer;
      touch-action:manipulation;
      user-select:none;
    }
    .cell.alt{ background:var(--cellB); }

    .cell.playhead{
      outline:4px solid var(--playhead);
      outline-offset:-4px;
      box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.5);
    }

    .cell.on.t1{ background:var(--t1); }
    .cell.on.t2{ background:var(--t2); }
    .cell.on.t3{ background:var(--t3); }
    .cell.on.t4{ background:var(--t4); }
    .cell.on.t5{ background:var(--t5); }
    .cell.on.t6{ background:var(--t6); }
    .cell.on.t7{ background:var(--t7); }
    .cell.on.t8{ background:var(--t8); }

    .statusLine{
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      flex:0 0 auto;
    }

    /* Bass/Lead */
    .seqControls{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:4px;
      flex:0 0 auto;
    }
    .seqControls .pill{ padding:4px 8px; font-size:11px; }
    .seqControls .pill input[type="range"]{ width:80px; }
    .seqControls .smallBtn{ height:26px; padding:0 8px; font-size:11px; }

    .tb_grid{
      display:grid;
      grid-template-columns: 30px repeat(16, 1fr);
      column-gap:2px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
    }
    .tb_labels,.tb_col{
      display:grid;
      grid-template-rows: 14px 42px 4px repeat(7, minmax(28px, 1fr));
      gap:3px;
      height:100%;
      min-height:0;
    }
    .tb_labels{ font-size:10px; color:var(--muted); user-select:none; }
    .tb_labels .muted{ font-size:9px; font-weight:950; letter-spacing:.2px; }
    .tb_stepNum{ text-align:center; font-size:10px; font-weight:1000; user-select:none; }

    .tb_oct{ display:grid; grid-template-rows:repeat(3,1fr); gap:2px; height:42px; }
    .tb_octBtn{
      width:100%;
      height:100%;
      border:1px solid var(--border);
      background:var(--card);
      color:var(--text);
      cursor:pointer;
      border-radius:6px;
      touch-action:manipulation;
      font-weight:1000;
      font-size:11px;
      line-height:1;
    }
    .tb_spacer{ height:4px; }
    .tb_pad{
      width:100%;
      height:100%;
      border:1px solid var(--border);
      background:var(--noteGrey);
      cursor:pointer;
      border-radius:8px;
      touch-action:manipulation;
      min-height:26px;
    }
    .tb_pad.nat{ background:var(--noteNat); }
    .bass .tb_pad.on{ background:var(--bassOn)!important; border-color:var(--bassOn)!important; }
    .bass .tb_octBtn.on.oct-up{ background:#dc2626!important; border-color:#b91c1c!important; color:#fff; }
    .bass .tb_octBtn.on.oct-mid{ background:var(--bassOn)!important; border-color:var(--bassOn)!important; color:#fff; }
    .bass .tb_octBtn.on.oct-down{ background:#7f1d1d!important; border-color:#5c1616!important; color:#fff; }
    .lead .tb_pad.on{ background:var(--leadOn)!important; border-color:var(--leadOn)!important; }
    .lead .tb_octBtn.on.oct-up{ background:#a855f7!important; border-color:#9333ea!important; color:#fff; }
    .lead .tb_octBtn.on.oct-mid{ background:var(--leadOn)!important; border-color:var(--leadOn)!important; color:#fff; }
    .lead .tb_octBtn.on.oct-down{ background:#4c1d95!important; border-color:#3b1578!important; color:#fff; }

    /* Mixer */
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
    }
    .chan{
      border:1px solid var(--border);
      border-radius:16px;
      padding:10px 12px;
      display:flex;
      flex-direction:row;
      align-items:center;
      gap:12px;
      min-height:0;
      background:#252525;
    }
    .chanTop{ display:flex; align-items:center; gap:8px; flex:0 0 auto; }
    .chanName{ font-weight:1000; font-size:13px; color:var(--text); white-space:nowrap; }
    .muteBtn{ height:30px; padding:0 10px; border-radius:12px; font-size:12px; font-weight:1000; }
    .muteBtn.on{ background:#ef4444; color:#fff; border-color:#dc2626; }

    .faderWrap{
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:flex-start;
      flex:1 1 auto;
      min-height:0;
    }
    .faderCol{ display:flex; flex-direction:row; align-items:center; gap:8px; flex:1 1 0; min-width:0; }
    .faderLabel{ font-size:11px; color:var(--muted); font-weight:950; white-space:nowrap; }
    .vfaderShell{ display:none; }
    .hfader{
      -webkit-appearance:none; appearance:none;
      width:100%; height:8px;
      background:rgba(255,255,255,.1);
      border-radius:4px;
      border:1px solid rgba(255,255,255,.15);
    }
    .hfader::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px; height:18px;
      border-radius:999px;
      background:#3b82f6;
      border:2px solid #2563eb;
      cursor:pointer;
    }
    .hfader::-moz-range-thumb{ width:18px; height:18px; border-radius:999px; background:#3b82f6; border:2px solid #2563eb; cursor:pointer; }
    
    /* Legacy vertical fader - hidden in this layout */
    .vfader{
      -webkit-appearance:none; appearance:none;
      width:180px; height:34px;
      background:transparent;
      transform:rotate(-90deg);
      display:none;
    }
    .vfader:focus{ outline:none; }
    .vfader::-webkit-slider-runnable-track{ height:8px; border-radius:999px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.15); }
    .vfader::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:26px; height:26px;
      border-radius:999px;
      background:#3b82f6;
      border:2px solid #2563eb;
      margin-top:-9px;
      cursor:pointer;
    }
    .vfader::-moz-range-track{ height:8px; border-radius:999px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.15); }
    .vfader::-moz-range-thumb{ width:26px; height:26px; border-radius:999px; background:#3b82f6; border:2px solid #2563eb; cursor:pointer; }

    footer{
      height:var(--footerH);
      border-top:1px solid var(--border);
      background:var(--card);
      display:flex;
      justify-content:flex-end;
      gap:var(--gap);
      padding:10px 12px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      z-index:40;
    }
    .footerSpacer{ flex:1; }
    .footerRight{ font-weight:900; color:var(--muted); }

    @media (max-width:900px){
      .wrap{ 
        padding: var(--gap);
      }
      .mixerGrid{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
  <header>
    <div class="headerTop">
      <div class="topLeft">
        <div class="pill">
          <span>Tempo</span>
          <input id="tempo" class="tempoRange" type="range" min="80" max="160" value="120">
          <strong id="tempoVal">120</strong>
        </div>
        <div class="pill">
          <span>Vol</span>
          <input id="masterVol" type="range" min="0" max="1" value="0.90" step="0.01">
        </div>
      </div>

      <div class="topMid">
        <button id="masterPlay" class="primary">▶ Play</button>
        <button id="masterStop" disabled>■ Stop</button>
      </div>

      <div class="topRight">
        <div class="loopSlots">
          <div class="loopSlot">
            <button class="loopBtn" id="loop1Btn" data-slot="0">1</button>
            <span class="loopStatus" id="loop1Status">Empty</span>
          </div>
          <div class="loopSlot">
            <button class="loopBtn" id="loop2Btn" data-slot="1">2</button>
            <span class="loopStatus" id="loop2Status">Empty</span>
          </div>
          <div class="loopSlot">
            <button class="loopBtn" id="loop3Btn" data-slot="2">3</button>
            <span class="loopStatus" id="loop3Status">Empty</span>
          </div>
          <div class="loopSlot">
            <button class="loopBtn" id="loop4Btn" data-slot="3">4</button>
            <span class="loopStatus" id="loop4Status">Empty</span>
          </div>
        </div>
        <button class="loopControlBtn stop" id="loopStopBtn">Stop</button>
        <button class="loopControlBtn" id="loopClearBtn">Clear</button>
        <button class="loopControlBtn" id="shareBtn" style="background:#8b5cf6;color:#fff;border-color:#7c3aed;">Share</button>
        <button class="loopControlBtn" id="loadShareBtn" style="background:#3b82f6;color:#fff;border-color:#2563eb;">Load</button>
        <button class="loopControlBtn" id="hubBtn" style="background:#22c55e;color:#fff;border-color:#16a34a;">Hub</button>
      </div>
    </div>
  </header>

  <!-- Share Modal -->
  <div id="shareModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:100;align-items:center;justify-content:center;">
    <div style="background:var(--card);border-radius:16px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto;">
      <h2 style="margin:0 0 16px;font-size:18px;color:var(--text);" id="shareModalTitle">Share Your Music</h2>
      
      <div id="shareExportSection">
        <label style="display:block;margin-bottom:8px;color:var(--muted);font-size:12px;">Your Name:</label>
        <input type="text" id="shareName" placeholder="Enter your name" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--border);background:var(--bg);color:var(--text);margin-bottom:16px;font-size:14px;">
        
        <label style="display:block;margin-bottom:8px;color:var(--muted);font-size:12px;">Share Code:</label>
        <textarea id="shareCode" readonly style="width:100%;height:80px;padding:10px;border-radius:8px;border:1px solid var(--border);background:var(--bg);color:var(--text);font-family:monospace;font-size:11px;resize:none;"></textarea>
        <button id="copyCodeBtn" style="margin-top:8px;padding:10px 20px;background:#22c55e;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">Copy Code</button>
      </div>
      
      <div id="shareImportSection" style="display:none;">
        <label style="display:block;margin-bottom:8px;color:var(--muted);font-size:12px;">Paste a Share Code:</label>
        <textarea id="loadCode" placeholder="Paste code here..." style="width:100%;height:80px;padding:10px;border-radius:8px;border:1px solid var(--border);background:var(--bg);color:var(--text);font-family:monospace;font-size:11px;resize:none;"></textarea>
        <button id="loadCodeBtn" style="margin-top:8px;padding:10px 20px;background:#3b82f6;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">▶ Load & Play</button>
        
        <div id="loadedProjectInfo" style="display:none;margin-top:16px;padding:12px;background:var(--bg);border-radius:8px;">
          <div style="font-weight:bold;color:var(--text);" id="loadedProjectName"></div>
          <div style="font-size:11px;color:var(--muted);margin-top:4px;" id="loadedProjectDetails"></div>
        </div>
      </div>
      
      <button id="closeModalBtn" style="margin-top:16px;padding:10px 20px;background:var(--border);color:var(--text);border:none;border-radius:8px;cursor:pointer;width:100%;">Close</button>
    </div>
  </div>

  <!-- Hub Modal -->
  <div id="hubModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:100;align-items:center;justify-content:center;">
    <div style="background:var(--card);border-radius:16px;padding:24px;max-width:600px;width:95%;max-height:90vh;overflow-y:auto;">
      <h2 style="margin:0 0 8px;font-size:20px;color:var(--text);">Classroom Hub</h2>
      
      <!-- Server URL Setting -->
      <div style="background:#1e3a5f;border-radius:8px;padding:10px;margin-bottom:16px;">
        <div style="display:flex;gap:8px;align-items:center;">
          <span style="font-size:11px;color:#93c5fd;white-space:nowrap;">Server:</span>
          <input type="text" id="hubServerUrl" placeholder="https://yoursite.com/music-hub.php" style="flex:1;padding:8px;border-radius:6px;border:none;background:#0f172a;color:#fff;font-size:12px;">
          <button id="hubSaveUrl" style="padding:8px 12px;background:#3b82f6;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:11px;">Save</button>
        </div>
        <div id="hubConnectionStatus" style="font-size:10px;color:#93c5fd;margin-top:6px;">Enter your server URL above</div>
      </div>
      
      <!-- Student Section -->
      <div id="hubStudentSection" style="background:var(--bg);border-radius:12px;padding:16px;margin-bottom:16px;">
        <h3 style="margin:0 0 12px;font-size:14px;color:#22c55e;">Submit Your Music</h3>
        <input type="text" id="hubStudentName" placeholder="Enter your name" style="width:100%;padding:12px;border-radius:8px;border:2px solid var(--border);background:var(--card);color:var(--text);font-size:16px;margin-bottom:12px;">
        <button id="hubSubmitBtn" style="width:100%;padding:14px;background:#22c55e;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:16px;">Submit to Hub</button>
        <div id="hubSubmitStatus" style="margin-top:8px;font-size:12px;color:var(--muted);text-align:center;"></div>
      </div>
      
      <!-- Teacher Section -->
      <div id="hubTeacherSection" style="background:var(--bg);border-radius:12px;padding:16px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
          <h3 style="margin:0;font-size:14px;color:#3b82f6;">Class Submissions (<span id="hubCount">0</span>)</h3>
          <button id="hubRefreshBtn" style="padding:6px 12px;background:#3b82f6;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;">Refresh</button>
        </div>
        <div id="hubProjectList" style="max-height:300px;overflow-y:auto;">
          <div style="color:var(--muted);text-align:center;padding:20px;font-size:13px;">Set server URL and click Refresh</div>
        </div>
        <div style="margin-top:12px;display:flex;gap:8px;">
          <button id="hubPlayAllBtn" style="flex:1;padding:10px;background:#8b5cf6;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">▶ Play All</button>
          <button id="hubStopBtn" style="padding:10px 16px;background:#f59e0b;color:#fff;border:none;border-radius:8px;cursor:pointer;font-size:12px;">Stop</button>
          <button id="hubClearAllBtn" style="padding:10px 16px;background:#dc2626;color:#fff;border:none;border-radius:8px;cursor:pointer;font-size:12px;"></button>
        </div>
      </div>
      
      <button id="closeHubBtn" style="margin-top:16px;padding:10px 20px;background:var(--border);color:var(--text);border:none;border-radius:8px;cursor:pointer;width:100%;">Close</button>
    </div>
  </div>

  <div class="wrap">
    <!-- DRUM MACHINE -->
    <div class="card drums">
      <div class="cardHead">
        <div class="title">Drum Machine</div>
        <div class="drumToolsCompact">
          <button id="saveFileBtn" class="smallBtn">Save</button>
          <button id="loadFileBtn" class="smallBtn">Load</button>
          <input id="loadFileInput" type="file" accept=".mmjson,application/json" style="display:none" />
          <button id="clear" class="smallBtn">Clear</button>
        </div>
      </div>

      <div class="body">
        <div class="samplerBar">
          <strong style="font-size:12px">Sample 1</strong>
          <button id="s1RecBtn" class="smallBtn">2s</button>
          <button id="s1PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s1ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s1Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s1Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s1Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s1PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s1Status" class="samplerStatus">No sample</span>
        </div>

        <div class="samplerBar">
          <strong style="font-size:12px">Sample 2</strong>
          <button id="s2RecBtn" class="smallBtn">2s</button>
          <button id="s2PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s2ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s2Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s2Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s2Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s2PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s2Status" class="samplerStatus">No sample</span>
        </div>

        <div class="gridWrap">
          <div class="headerRow" id="headerRow"></div>
          <div id="grid"></div>
        </div>

        <div class="statusLine">
          <div id="statusLeft"></div>
          <div id="statusRight"></div>
        </div>
      </div>
    </div>

    <!-- TRANCE LEAD -->
    <div class="card card-lead">
      <div class="cardHead">
        <div class="title">Trance Lead</div>
        <div></div>
      </div>

      <div class="body lead">
        <div class="seqControls">
          <button id="leadReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="lCutoff" type="range" min="0" max="1" step="0.001" value="0.36"></div>
          <div class="pill"><span>Res</span><input id="lReso" type="range" min="0" max="1" step="0.01" value="0.20"></div>
          <div class="pill"><span>Env</span><input id="lEnv" type="range" min="0" max="1" step="0.01" value="0.40"></div>
          <div class="pill"><span>Gate</span><input id="lGate" type="range" min="0.10" max="1" step="0.01" value="0.55"></div>

          <div class="pill"><span>Mix</span><input id="lMix" type="range" min="0" max="1" step="0.01" value="0.14"></div>
          <div class="pill"><span>FB</span><input id="lFb" type="range" min="0" max="0.75" step="0.01" value="0.18"></div>
        </div>

        <div id="lead_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- BASSLINE -->
    <div class="card card-bass">
      <div class="cardHead">
        <div class="title">Bassline</div>
        <div></div>
      </div>

      <div class="body bass">
        <div class="seqControls">
          <button id="bassReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="cutoff" type="range" min="0" max="1" step="0.001" value="0.28"></div>
          <div class="pill"><span>Res</span><input id="reso" type="range" min="0" max="1" step="0.01" value="0.18"></div>
          <div class="pill"><span>Env</span><input id="env" type="range" min="0" max="1" step="0.01" value="0.32"></div>
          <div class="pill"><span>Decay</span><input id="bDecay" type="range" min="0.08" max="0.60" step="0.01" value="0.28"></div>

          <div class="pill"><span>Mix</span><input id="dMix" type="range" min="0" max="1" step="0.01" value="0.16"></div>
          <div class="pill"><span>FB</span><input id="dFb" type="range" min="0" max="0.75" step="0.01" value="0.20"></div>
        </div>

        <div id="tb_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- MIXER -->
    <div class="card card-mixer">
      <div class="cardHead">
        <div class="title">Mixer</div>
        <div></div>
      </div>

      <div class="body">
        <div class="pill" style="justify-content:space-between;gap:12px;">
          <span style="font-weight:950;color:var(--text)">Sidechain</span>
          <input id="sidechainAmt" type="range" min="0" max="1" step="0.01" value="0.22" style="width:180px">
          <strong id="sidechainVal">0.22</strong>
        </div>

        <div class="mixerGrid">
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Drums</div>
              <button id="mDrumMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <input id="mDrumVol" class="hfader" type="range" min="0" max="1" step="0.01" value="0.22">
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <input id="mDrumLPF" class="hfader" type="range" min="0" max="1" step="0.01" value="1.00">
              </div>
            </div>
          </div>

          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Bass</div>
              <button id="mBassMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <input id="mBassVol" class="hfader" type="range" min="0" max="1" step="0.01" value="0.22">
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <input id="mBassLPF" class="hfader" type="range" min="0" max="1" step="0.01" value="1.00">
              </div>
            </div>
          </div>

          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Lead</div>
              <button id="mLeadMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <input id="mLeadVol" class="hfader" type="range" min="0" max="1" step="0.01" value="0.26">
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <input id="mLeadLPF" class="hfader" type="range" min="0" max="1" step="0.01" value="1.00">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <div class="footerSpacer"></div>
    <div class="footerRight">Muziek met meester Luis 2026</div>
  </footer>

  <script>
  (() => {
    "use strict";

    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function safeJSONParse(s){ try{ return JSON.parse(s); }catch(_){ return null; } }
    function expMap01(x, minHz, maxHz){
      x = clamp(x, 0, 1);
      const a = Math.log(minHz);
      const b = Math.log(maxHz);
      return Math.exp(a + (b-a)*x);
    }

    const tempoEl = document.getElementById("tempo");
    const tempoVal = document.getElementById("tempoVal");
    const masterVolEl = document.getElementById("masterVol");
    const masterPlayBtn = document.getElementById("masterPlay");
    const masterStopBtn = document.getElementById("masterStop");

    const statusLeft  = document.getElementById("statusLeft");
    const statusRight = document.getElementById("statusRight");
    function setStatus(t){ statusLeft.textContent = t || ""; }

    function bindInput(el, fn){
      el.addEventListener("input", fn, {passive:true});
      el.addEventListener("change", fn, {passive:true});
    }

    function tempo(){ return clamp(parseFloat(tempoEl.value||120), 80, 160); }
    function quarterSec(){ return 60/tempo(); }
    function dotted8Sec(){ return quarterSec()*0.75; }
    function sixteenthSec(){ return quarterSec()/4; }
    function fourBarsSec(){ return quarterSec() * 16; } // 4 bars = 16 beats

    tempoVal.textContent = String(tempo());
    bindInput(tempoEl, () => {
      tempoVal.textContent = String(tempo());
      if(ctx){
        if(bassDelayFX) bassDelayFX.update(false);
        if(leadDelayFX) leadDelayFX.update(false);
      }
      scheduleSave();
    });

    // ---------- Loop Recording System ----------
    const loopBtns = [
      document.getElementById("loop1Btn"),
      document.getElementById("loop2Btn"),
      document.getElementById("loop3Btn"),
      document.getElementById("loop4Btn")
    ];
    const loopStatuses = [
      document.getElementById("loop1Status"),
      document.getElementById("loop2Status"),
      document.getElementById("loop3Status"),
      document.getElementById("loop4Status")
    ];
    const loopStopBtn = document.getElementById("loopStopBtn");
    const loopClearBtn = document.getElementById("loopClearBtn");

    // Loop state: each slot stores pattern data (like MIDI), not audio
    // Pattern data: { drums: [...], bass: {...}, lead: {...}, params: {...} }
    const loopSlots = [null, null, null, null];
    let armedSlot = -1; // Which slot is armed for recording (-1 = none)
    let recordingSlot = -1; // Which slot is currently recording (-1 = none)
    let recordingBarCount = 0; // Current bar being recorded (1-4)
    let playingSlot = -1; // Which slot is playing (-1 = none)
    let pendingPlaySlot = -1; // Which slot is queued to play
    let loopBarsPlayed = 0; // How many bars the current loop has played (1-4)
    let currentBar = 0; // Current bar in the 4-bar cycle (1-4), increments at step 0
    let loopBarTimer = null; // Timer for tracking bars when playing independently
    let loopScheduler = null; // Scheduler for independent loop playback
    let loopStep = 0; // Current step in independent loop playback
    let loopNextTime = 0; // Next scheduled time for independent loop

    function updateLoopUI(){
      loopBtns.forEach((btn, i) => {
        btn.classList.remove("armed", "recording", "ready", "playing", "pending");
        loopStatuses[i].classList.remove("armed", "recording", "ready", "playing", "pending");
        
        if(i === armedSlot){
          btn.classList.add("armed");
          loopStatuses[i].textContent = "Armed";
          loopStatuses[i].classList.add("armed");
        } else if(i === recordingSlot){
          btn.classList.add("recording");
          loopStatuses[i].textContent = `Rec ${recordingBarCount}/4`;
          loopStatuses[i].classList.add("recording");
        } else if(i === pendingPlaySlot){
          btn.classList.add("pending");
          const barsLeft = 5 - loopBarsPlayed; // loopBarsPlayed is 1-4
          loopStatuses[i].textContent = barsLeft > 0 ? `In ${barsLeft}` : "Next";
          loopStatuses[i].classList.add("pending");
        } else if(i === playingSlot){
          btn.classList.add("playing");
          loopStatuses[i].textContent = `${loopBarsPlayed}/4`;
          loopStatuses[i].classList.add("playing");
        } else if(loopSlots[i]){
          btn.classList.add("ready");
          loopStatuses[i].textContent = "Ready";
          loopStatuses[i].classList.add("ready");
        } else {
          loopStatuses[i].textContent = "Empty";
        }
      });
    }

    function armLoopSlot(slot){
      if(recordingSlot >= 0) return; // Can't arm while recording
      
      if(armedSlot === slot){
        // Toggle off
        armedSlot = -1;
      } else {
        armedSlot = slot;
      }
      updateLoopUI();
    }

    function startLoopRecording(slot){
      if(!ctx) return;
      
      recordingSlot = slot;
      recordingBarCount = 1;
      armedSlot = -1;
      
      // Helper to get numeric value with proper 0 handling
      function getVal(el, def){
        var v = parseFloat(el.value);
        return isFinite(v) ? v : def;
      }
      
      // Capture current pattern state as "MIDI" data
      var patternData = {
        drums: tracks.map(function(tr){
          return {
            key: tr.key,
            pattern: tr.pattern.slice(),
            vol: tr.vol
          };
        }),
        bass: {
          steps: bassState.steps.map(function(s){ return { note: s.note, oct: s.oct }; })
        },
        lead: {
          steps: leadState.steps.map(function(s){ return { note: s.note, oct: s.oct }; })
        },
        params: {
          bass: {
            cut: getVal(cutEl, 0),
            res: getVal(resEl, 0),
            env: getVal(envEl, 0),
            dec: getVal(bDecayEl, 0.28)
          },
          lead: {
            cut: getVal(lCutEl, 0),
            res: getVal(lResEl, 0),
            env: getVal(lEnvEl, 0),
            gate: getVal(lGateEl, 0.55)
          },
          mixer: {
            dV: getVal(mDrumVolEl, 0.8),
            bV: getVal(mBassVolEl, 0.75),
            lV: getVal(mLeadVolEl, 0.7),
            dF: getVal(mDrumLPFEl, 1),
            bF: getVal(mBassLPFEl, 1),
            lF: getVal(mLeadLPFEl, 1)
          },
          mutes: {
            drum: mute.drums ? 1 : 0,
            bass: mute.bass ? 1 : 0,
            lead: mute.lead ? 1 : 0
          }
        },
        tempo: tempo()
      };
      
      loopSlots[slot] = patternData;
      
      updateLoopUI();
      setStatus("Recording Loop " + (slot + 1) + "... (Bar 1/4)");
    }

    function incrementBarCount(){
      if(recordingSlot < 0) return false;
      recordingBarCount++;
      updateLoopUI();
      setStatus(`Recording Loop ${recordingSlot + 1}... (Bar ${recordingBarCount}/4)`);
      return recordingBarCount >= 4;
    }

    function stopLoopRecording(){
      if(recordingSlot < 0) return;
      
      const slot = recordingSlot;
      setStatus("Loop " + (slot + 1) + " recorded!");
      
      recordingSlot = -1;
      recordingBarCount = 0;
      updateLoopUI();
    }

    function queueLoop(slot){
      ensureAudio();
      
      if(!ctx || !loopSlots[slot]) return;
      
      if(playingSlot === slot){
        stopLoopPlayback();
        setStatus(`Loop ${slot + 1} stopped`);
        return;
      }
      
      if(pendingPlaySlot === slot){
        pendingPlaySlot = -1;
        updateLoopUI();
        setStatus(`Loop ${slot + 1} cancelled`);
        return;
      }
      
      if(playingSlot >= 0){
        pendingPlaySlot = slot;
        updateLoopUI();
        const barsLeft = 5 - loopBarsPlayed;
        setStatus(`Loop ${slot + 1} queued - plays in ${barsLeft} bar${barsLeft !== 1 ? 's' : ''}`);
        return;
      }
      
      playingSlot = slot;
      loopBarsPlayed = 1;
      triggerLoopAudio(slot, ctx.currentTime);
      setStatus(`Playing Loop ${slot + 1}`);
      updateLoopUI();
    }

    // Start scheduler for independent loop playback (pattern-based, like MIDI)
    function startLoopScheduler(){
      stopLoopScheduler();
      if(playingSlot < 0 || !loopSlots[playingSlot]) return;
      
      ensureSynths();
      
      // Apply mixer settings from the loop
      var pattern = loopSlots[playingSlot];
      if(pattern) {
        applyProjectMixer(pattern);
      }
      
      loopStep = 0;
      loopNextTime = ctx.currentTime + 0.02;
      var needsUIUpdate = false;
      var newStatusMsg = null;
      
      function scheduleLoopStep(){
        if(playingSlot < 0) return;
        
        var stepDur = sixteenthSec();
        var lookAhead = 0.1;
        needsUIUpdate = false;
        newStatusMsg = null;
        
        while(loopNextTime < ctx.currentTime + lookAhead){
          // Get current pattern each iteration (in case of switch)
          var currentPattern = loopSlots[playingSlot];
          if(!currentPattern) return;
          
          playLoopStep(currentPattern, loopStep, loopNextTime);
          
          loopStep++;
          if(loopStep >= 16){
            loopStep = 0;
            loopBarsPlayed++;
            needsUIUpdate = true;
            
            if(loopBarsPlayed > 4){
              loopBarsPlayed = 1;
              // Check for pending loop switch
              if(pendingPlaySlot >= 0){
                playingSlot = pendingPlaySlot;
                pendingPlaySlot = -1;
                // Apply new loop's mixer settings
                var newPattern = loopSlots[playingSlot];
                if(newPattern) {
                  applyProjectMixer(newPattern);
                }
                newStatusMsg = "Playing Loop " + (playingSlot + 1);
              }
            }
          }
          
          loopNextTime += stepDur;
        }
        
        // Do UI updates AFTER audio scheduling is done
        if(needsUIUpdate) updateLoopUI();
        if(newStatusMsg) setStatus(newStatusMsg);
        
        loopScheduler = setTimeout(scheduleLoopStep, 20);
      }
      
      scheduleLoopStep();
    }
    
    function stopLoopScheduler(){
      if(loopScheduler){
        clearTimeout(loopScheduler);
        loopScheduler = null;
      }
    }
    
    // Play a single step from pattern data
    function playLoopStep(pattern, stepIndex, time){
      if(!ctx || !pattern || !isFinite(time)) return;
      
      // Play drums
      if(pattern.drums){
        for(var i = 0; i < pattern.drums.length; i++){
          var drumTrack = pattern.drums[i];
          if(drumTrack.pattern && drumTrack.pattern[stepIndex]){
            var tr = tracks.find(function(t){ return t.key === drumTrack.key; });
            if(tr && tr.buffer){
              if(drumTrack.key === "kick") triggerSidechain(time);
              
              var g = ensureTrackGain(drumTrack.key);
              setTrackGain(drumTrack.key, drumTrack.vol || 0.8, true);
              
              if(tr.isSampler){
                if(drumTrack.key === "sample1") playSampleNow(1, time);
                else if(drumTrack.key === "sample2") playSampleNow(2, time);
              } else {
                playBufferAt(tr.buffer, time, g);
              }
            }
          }
        }
      }
      
      // Get params with safe defaults
      var bp = (pattern.params && pattern.params.bass) || {};
      var lp = (pattern.params && pattern.params.lead) || {};
      
      // Safe number function
      function safeNum(val, def){
        var n = Number(val);
        return isFinite(n) ? n : def;
      }
      
      // Play bass - use octave directly (no +1)
      if(pattern.bass && pattern.bass.steps && pattern.bass.steps[stepIndex]){
        var bassData = pattern.bass.steps[stepIndex];
        if(bassData.note){
          var bassFreq = hzForNote(bassData.note, safeNum(bassData.oct, 0));
          if(isFinite(bassFreq) && bassFreq > 0){
            bassSynth.trigger({
              freq: bassFreq,
              time: time,
              decay: safeNum(bp.dec, 0.28),
              gate: 0.55,
              envAmt: safeNum(bp.env, 0),
              baseCut01: safeNum(bp.cut, 0),
              release: 0.10,
              vel: 1.0
            });
          }
        }
      }
      
      // Play lead - add +1 octave (matches original scheduleLead)
      if(pattern.lead && pattern.lead.steps && pattern.lead.steps[stepIndex]){
        var leadData = pattern.lead.steps[stepIndex];
        if(leadData.note){
          var leadFreq = hzForNote(leadData.note, safeNum(leadData.oct, 0) + 1);
          if(isFinite(leadFreq) && leadFreq > 0){
            leadSynth.trigger({
              freq: leadFreq,
              time: time,
              decay: 0.22,
              gate: safeNum(lp.gate, 0.55),
              envAmt: safeNum(lp.env, 0),
              baseCut01: safeNum(lp.cut, 0),
              release: 0.11,
              vel: 1.0
            });
          }
        }
      }
    }
    
    function triggerLoopAudio(slot, time){
      if(!ctx || !loopSlots[slot]) return;
      
      if(!isRunning){
        startLoopScheduler();
      }
    }
    
    function stopLoopBarTimer(){
      stopLoopScheduler();
    }

    function playLoop(slot){
      queueLoop(slot);
    }

    function stopLoopPlayback(){
      pendingPlaySlot = -1;
      playingSlot = -1;
      loopBarsPlayed = 0;
      loopStep = 0;
      stopLoopScheduler();
      updateLoopUI();
    }

    function clearAllLoops(){
      stopLoopPlayback();
      if(recordingSlot >= 0) stopLoopRecording();
      armedSlot = -1;
      for(let i = 0; i < 4; i++){
        loopSlots[i] = null;
      }
      updateLoopUI();
      setStatus("All loops cleared");
    }

    // Loop button click handlers
    loopBtns.forEach((btn, i) => {
      btn.addEventListener("click", async () => {
        ensureAudio();
        await resumeAudio();
        
        if(loopSlots[i]){
          queueLoop(i);
        } else if(!isRunning){
          armLoopSlot(i);
          setStatus(`Loop ${i + 1} armed. Press Play to start recording.`);
        } else {
          armLoopSlot(i);
          setStatus(`Loop ${i + 1} armed. Recording starts at next bar 1.`);
        }
      });
    });

    loopStopBtn.addEventListener("click", () => {
      stopLoopPlayback();
      if(recordingSlot >= 0) stopLoopRecording();
      setStatus("Loop stopped");
    });

    loopClearBtn.addEventListener("click", clearAllLoops);

    // ---------- SHARE FUNCTIONALITY ----------
    const shareModal = document.getElementById("shareModal");
    const shareBtn = document.getElementById("shareBtn");
    const loadShareBtn = document.getElementById("loadShareBtn");
    const shareExportSection = document.getElementById("shareExportSection");
    const shareImportSection = document.getElementById("shareImportSection");
    const shareModalTitle = document.getElementById("shareModalTitle");
    const shareName = document.getElementById("shareName");
    const shareCode = document.getElementById("shareCode");
    const copyCodeBtn = document.getElementById("copyCodeBtn");
    const loadCode = document.getElementById("loadCode");
    const loadCodeBtn = document.getElementById("loadCodeBtn");
    const closeModalBtn = document.getElementById("closeModalBtn");
    const loadedProjectInfo = document.getElementById("loadedProjectInfo");
    const loadedProjectName = document.getElementById("loadedProjectName");
    const loadedProjectDetails = document.getElementById("loadedProjectDetails");

    function generateShareCode(){
      // Compact format: much shorter code
      const d = {
        n: shareName.value || "?",
        t: tempo(),
        // Drums: convert each pattern to hex (16 bits = 4 hex chars)
        dr: tracks.map(tr => {
          let bits = 0;
          for(let i = 0; i < 16; i++) if(tr.pattern[i]) bits |= (1 << i);
          return bits.toString(16).padStart(4, '0');
        }).join(''),
        // Bass: note letters + octave (e.g., "A0C1E0" or "-" for empty)
        ba: bassState.steps.map(s => s.note ? s.note[0] + s.oct : '-').join(''),
        // Lead: same format
        le: leadState.steps.map(s => s.note ? s.note[0] + s.oct : '-').join(''),
        // Params: rounded to 1 decimal
        p: [
          Math.round(+cutEl.value * 10) / 10,
          Math.round(+resEl.value * 10) / 10,
          Math.round(+envEl.value * 10) / 10,
          Math.round(+bDecayEl.value * 100) / 100,
          Math.round(+lCutEl.value * 10) / 10,
          Math.round(+lResEl.value * 10) / 10,
          Math.round(+lEnvEl.value * 10) / 10,
          Math.round(+lGateEl.value * 100) / 100
        ]
      };
      
      const json = JSON.stringify(d);
      return btoa(json).replace(/=/g, '');
    }

    function parseShareCode(code){
      try {
        // Add back padding if needed
        while(code.length % 4 !== 0) code += '=';
        const json = atob(code.trim());
        const d = JSON.parse(json);
        
        // Convert back to full format
        const noteMap = { 'A': 'A', 'B': 'B', 'C': 'C', 'D': 'D', 'E': 'E', 'F': 'F', 'G': 'G' };
        
        // Parse drums from hex
        const drumPatterns = [];
        for(let i = 0; i < 8; i++){
          const hex = d.dr.substr(i * 4, 4);
          const bits = parseInt(hex, 16);
          const pattern = [];
          for(let j = 0; j < 16; j++) pattern.push(!!(bits & (1 << j)));
          drumPatterns.push(pattern);
        }
        
        // Parse bass
        const bassSteps = [];
        for(let i = 0; i < 16; i++){
          const ch = d.ba[i * 2];
          const oct = d.ba[i * 2 + 1];
          if(ch === '-'){
            bassSteps.push({ note: null, oct: 0 });
          } else {
            bassSteps.push({ note: ch, oct: parseInt(oct) || 0 });
          }
        }
        
        // Parse lead
        const leadSteps = [];
        for(let i = 0; i < 16; i++){
          const ch = d.le[i * 2];
          const oct = d.le[i * 2 + 1];
          if(ch === '-'){
            leadSteps.push({ note: null, oct: 0 });
          } else {
            leadSteps.push({ note: ch, oct: parseInt(oct) || 0 });
          }
        }
        
        return {
          name: d.n,
          tempo: d.t,
          drums: tracks.map((tr, i) => ({
            key: tr.key,
            pattern: drumPatterns[i] || new Array(16).fill(false),
            vol: tr.vol
          })),
          bass: { steps: bassSteps },
          lead: { steps: leadSteps },
          params: {
            bass: { cut: d.p[0], res: d.p[1], env: d.p[2], dec: d.p[3], mix: 0, fb: 0 },
            lead: { cut: d.p[4], res: d.p[5], env: d.p[6], gate: d.p[7], mix: 0, fb: 0 },
            mixer: { dV: 0.8, bV: 0.75, lV: 0.7, dF: 1, bF: 1, lF: 1 }
          }
        };
      } catch(e) {
        console.error("Failed to parse share code:", e);
        return null;
      }
    }

    function loadProjectFromData(data){
      if(!data) return false;
      
      // Set tempo
      if(data.tempo) tempoEl.value = data.tempo;
      
      // Load drum patterns
      if(data.drums){
        for(const drumData of data.drums){
          const tr = tracks.find(t => t.key === drumData.key);
          if(tr && drumData.pattern){
            tr.pattern = [...drumData.pattern];
            if(drumData.vol !== undefined) tr.vol = drumData.vol;
          }
        }
        renderDrumGrid();
      }
      
      // Load bass
      if(data.bass && data.bass.steps){
        bassState.steps = data.bass.steps.map(s => ({ note: s.note, oct: s.oct || 0 }));
        renderSeqGrid(bassState, bassGridEl, "bass");
      }
      
      // Load lead
      if(data.lead && data.lead.steps){
        leadState.steps = data.lead.steps.map(s => ({ note: s.note, oct: s.oct || 0 }));
        renderSeqGrid(leadState, leadGridEl, "lead");
      }
      
      // Load params
      if(data.params){
        if(data.params.bass){
          if(data.params.bass.cut !== undefined) cutEl.value = data.params.bass.cut;
          if(data.params.bass.res !== undefined) resEl.value = data.params.bass.res;
          if(data.params.bass.env !== undefined) envEl.value = data.params.bass.env;
          if(data.params.bass.dec !== undefined) bDecayEl.value = data.params.bass.dec;
        }
        if(data.params.lead){
          if(data.params.lead.cut !== undefined) lCutEl.value = data.params.lead.cut;
          if(data.params.lead.res !== undefined) lResEl.value = data.params.lead.res;
          if(data.params.lead.env !== undefined) lEnvEl.value = data.params.lead.env;
          if(data.params.lead.gate !== undefined) lGateEl.value = data.params.lead.gate;
        }
      }
      
      // Store as a loop so it can be played
      loopSlots[0] = {
        drums: data.drums,
        bass: data.bass,
        lead: data.lead,
        params: data.params,
        tempo: data.tempo
      };
      updateLoopUI();
      
      return true;
    }

    shareBtn.addEventListener("click", () => {
      shareModalTitle.textContent = "Share Your Music";
      shareExportSection.style.display = "block";
      shareImportSection.style.display = "none";
      shareCode.value = generateShareCode();
      shareModal.style.display = "flex";
    });

    loadShareBtn.addEventListener("click", () => {
      shareModalTitle.textContent = "Load a Project";
      shareExportSection.style.display = "none";
      shareImportSection.style.display = "block";
      loadCode.value = "";
      loadedProjectInfo.style.display = "none";
      shareModal.style.display = "flex";
    });

    copyCodeBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(shareCode.value);
        copyCodeBtn.textContent = "✓ Copied!";
        setTimeout(() => { copyCodeBtn.textContent = "Copy Code"; }, 2000);
      } catch(e) {
        shareCode.select();
        document.execCommand("copy");
        copyCodeBtn.textContent = "✓ Copied!";
        setTimeout(() => { copyCodeBtn.textContent = "Copy Code"; }, 2000);
      }
    });

    loadCode.addEventListener("input", () => {
      const data = parseShareCode(loadCode.value);
      if(data){
        loadedProjectInfo.style.display = "block";
        loadedProjectName.textContent = data.name || "Unnamed Project";
        loadedProjectDetails.textContent = `Tempo: ${data.tempo || 120} BPM`;
      } else {
        loadedProjectInfo.style.display = "none";
      }
    });

    loadCodeBtn.addEventListener("click", async () => {
      const data = parseShareCode(loadCode.value);
      if(!data){
        alert("Invalid share code!");
        return;
      }
      
      await resumeAudio();
      ensureSynths();
      
      if(loadProjectFromData(data)){
        shareModal.style.display = "none";
        setStatus(`Loaded: ${data.name || "Unnamed"}`);
        
        // Auto-play the loaded project
        playingSlot = 0;
        loopBarsPlayed = 1;
        triggerLoopAudio(0, ctx.currentTime);
        updateLoopUI();
        setStatus(`Playing: ${data.name || "Unnamed"}`);
      } else {
        alert("Failed to load project!");
      }
    });

    closeModalBtn.addEventListener("click", () => {
      shareModal.style.display = "none";
    });

    shareModal.addEventListener("click", (e) => {
      if(e.target === shareModal) shareModal.style.display = "none";
    });

    // ---------- CLASSROOM HUB ----------
    const hubModal = document.getElementById("hubModal");
    const hubBtn = document.getElementById("hubBtn");
    const hubServerUrl = document.getElementById("hubServerUrl");
    const hubSaveUrl = document.getElementById("hubSaveUrl");
    const hubConnectionStatus = document.getElementById("hubConnectionStatus");
    const hubStudentName = document.getElementById("hubStudentName");
    const hubSubmitBtn = document.getElementById("hubSubmitBtn");
    const hubSubmitStatus = document.getElementById("hubSubmitStatus");
    const hubRefreshBtn = document.getElementById("hubRefreshBtn");
    const hubProjectList = document.getElementById("hubProjectList");
    const hubCount = document.getElementById("hubCount");
    const hubPlayAllBtn = document.getElementById("hubPlayAllBtn");
    const hubStopBtn = document.getElementById("hubStopBtn");
    const hubClearAllBtn = document.getElementById("hubClearAllBtn");
    const closeHubBtn = document.getElementById("closeHubBtn");
    
    let hubProjects = [];
    let hubPlayIndex = -1;
    let hubPlaying = false;
    
    // Load saved server URL
    const savedHubUrl = localStorage.getItem("musicHubServerUrl") || "";
    hubServerUrl.value = savedHubUrl;
    
    // Save server URL
    hubSaveUrl.addEventListener("click", () => {
      const url = hubServerUrl.value.trim();
      localStorage.setItem("musicHubServerUrl", url);
      hubConnectionStatus.textContent = "URL saved! Click Refresh to test.";
      hubConnectionStatus.style.color = "#4ade80";
    });
    
    // Generate compact project data
    function getProjectData(){
      function getVal(el){
        var v = parseFloat(el.value);
        return isFinite(v) ? Math.round(v * 100) / 100 : 0;
      }
      
      return {
        t: tempo(),
        dr: tracks.map(function(tr){
          var bits = 0;
          for(var i = 0; i < 16; i++) if(tr.pattern[i]) bits |= (1 << i);
          return bits.toString(16).padStart(4, '0');
        }).join(''),
        dv: tracks.map(function(tr){ return Math.round(tr.vol * 100) / 100; }),
        ba: bassState.steps.map(function(s){ return s.note ? s.note[0] + s.oct : '--'; }).join(''),
        le: leadState.steps.map(function(s){ return s.note ? s.note[0] + s.oct : '--'; }).join(''),
        p: [
          getVal(cutEl),
          getVal(resEl),
          getVal(envEl),
          getVal(bDecayEl),
          getVal(lCutEl),
          getVal(lResEl),
          getVal(lEnvEl),
          getVal(lGateEl)
        ],
        m: [
          getVal(mDrumVolEl),
          getVal(mBassVolEl),
          getVal(mLeadVolEl),
          getVal(mDrumLPFEl),
          getVal(mBassLPFEl),
          getVal(mLeadLPFEl)
        ],
        mt: [
          mute.drums ? 1 : 0,
          mute.bass ? 1 : 0,
          mute.lead ? 1 : 0
        ]
      };
    }
    
    // Parse compact project data
    function parseProjectData(d){
      if(!d) return null;
      
      const drumPatterns = [];
      for(let i = 0; i < 8; i++){
        const hex = d.dr ? d.dr.substr(i * 4, 4) : '0000';
        const bits = parseInt(hex, 16) || 0;
        const pattern = [];
        for(let j = 0; j < 16; j++) pattern.push(!!(bits & (1 << j)));
        drumPatterns.push(pattern);
      }
      
      // Drum volumes
      const drumVols = d.dv || tracks.map(t => t.vol);
      
      const bassSteps = [];
      for(let i = 0; i < 16; i++){
        const ch = d.ba ? d.ba[i * 2] : '-';
        const oct = d.ba ? d.ba[i * 2 + 1] : '0';
        bassSteps.push(ch === '-' ? { note: null, oct: 0 } : { note: ch, oct: parseInt(oct) || 0 });
      }
      
      const leadSteps = [];
      for(let i = 0; i < 16; i++){
        const ch = d.le ? d.le[i * 2] : '-';
        const oct = d.le ? d.le[i * 2 + 1] : '0';
        leadSteps.push(ch === '-' ? { note: null, oct: 0 } : { note: ch, oct: parseInt(oct) || 0 });
      }
      
      const p = d.p || [0,0,0,0.28,0,0,0,0.55];
      const m = d.m || [0.8,0.75,0.7,1,1,1];
      const mt = d.mt || [0,0,0];
      
      return {
        tempo: d.t || 120,
        drums: tracks.map((tr, i) => ({
          key: tr.key,
          pattern: drumPatterns[i] || new Array(16).fill(false),
          vol: drumVols[i] !== undefined ? drumVols[i] : tr.vol
        })),
        bass: { steps: bassSteps },
        lead: { steps: leadSteps },
        params: {
          bass: { cut: p[0], res: p[1], env: p[2], dec: p[3] },
          lead: { cut: p[4], res: p[5], env: p[6], gate: p[7] },
          mixer: { dV: m[0], bV: m[1], lV: m[2], dF: m[3], bF: m[4], lF: m[5] },
          mutes: { drum: mt[0], bass: mt[1], lead: mt[2] }
        }
      };
    }
    
    // Submit to server
    hubSubmitBtn.addEventListener("click", async () => {
      const url = hubServerUrl.value.trim();
      const name = hubStudentName.value.trim();
      
      if(!url){
        hubSubmitStatus.textContent = "Set server URL first!";
        hubSubmitStatus.style.color = "#f87171";
        return;
      }
      
      if(!name){
        hubSubmitStatus.textContent = "Enter your name!";
        hubSubmitStatus.style.color = "#f87171";
        return;
      }
      
      // Check if any loops are recorded
      const hasLoops = loopSlots.some(s => s !== null);
      if(!hasLoops){
        hubSubmitStatus.textContent = "Record at least one loop first!";
        hubSubmitStatus.style.color = "#f87171";
        return;
      }
      
      hubSubmitStatus.textContent = "Submitting...";
      hubSubmitStatus.style.color = "#fbbf24";
      
      // Convert loop slots to compact format
      function slotToCompact(slot){
        if(!slot) return null;
        return {
          t: slot.tempo || tempo(),
          dr: slot.drums ? slot.drums.map(function(tr){
            var bits = 0;
            for(var i = 0; i < 16; i++) if(tr.pattern && tr.pattern[i]) bits |= (1 << i);
            return bits.toString(16).padStart(4, '0');
          }).join('') : '',
          dv: slot.drums ? slot.drums.map(function(tr){ return Math.round((tr.vol || 0.8) * 100) / 100; }) : [],
          ba: slot.bass && slot.bass.steps ? slot.bass.steps.map(function(s){ return s.note ? s.note[0] + (s.oct || 0) : '--'; }).join('') : '',
          le: slot.lead && slot.lead.steps ? slot.lead.steps.map(function(s){ return s.note ? s.note[0] + (s.oct || 0) : '--'; }).join('') : '',
          p: slot.params ? [
            (slot.params.bass && isFinite(slot.params.bass.cut)) ? slot.params.bass.cut : 0,
            (slot.params.bass && isFinite(slot.params.bass.res)) ? slot.params.bass.res : 0,
            (slot.params.bass && isFinite(slot.params.bass.env)) ? slot.params.bass.env : 0,
            (slot.params.bass && isFinite(slot.params.bass.dec)) ? slot.params.bass.dec : 0.28,
            (slot.params.lead && isFinite(slot.params.lead.cut)) ? slot.params.lead.cut : 0,
            (slot.params.lead && isFinite(slot.params.lead.res)) ? slot.params.lead.res : 0,
            (slot.params.lead && isFinite(slot.params.lead.env)) ? slot.params.lead.env : 0,
            (slot.params.lead && isFinite(slot.params.lead.gate)) ? slot.params.lead.gate : 0.55
          ] : [0,0,0,0.28,0,0,0,0.55],
          m: slot.params && slot.params.mixer ? [
            isFinite(slot.params.mixer.dV) ? slot.params.mixer.dV : 0.8,
            isFinite(slot.params.mixer.bV) ? slot.params.mixer.bV : 0.75,
            isFinite(slot.params.mixer.lV) ? slot.params.mixer.lV : 0.7,
            isFinite(slot.params.mixer.dF) ? slot.params.mixer.dF : 1,
            isFinite(slot.params.mixer.bF) ? slot.params.mixer.bF : 1,
            isFinite(slot.params.mixer.lF) ? slot.params.mixer.lF : 1
          ] : [0.8,0.75,0.7,1,1,1],
          mt: slot.params && slot.params.mutes ? [
            slot.params.mutes.drum ? 1 : 0,
            slot.params.mutes.bass ? 1 : 0,
            slot.params.mutes.lead ? 1 : 0
          ] : [0,0,0]
        };
      }
      
      var slots = loopSlots.map(slotToCompact);
      
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'submit',
            name: name,
            data: { slots: slots }
          })
        });
        
        const result = await res.json();
        
        if(result.success){
          hubSubmitStatus.textContent = '"' + name + '" submitted!';
          hubSubmitStatus.style.color = "#4ade80";
          localStorage.setItem("musicHubStudentName", name);
        } else {
          hubSubmitStatus.textContent = result.error || 'Failed';
          hubSubmitStatus.style.color = "#f87171";
        }
      } catch(e){
        hubSubmitStatus.textContent = "Connection error";
        hubSubmitStatus.style.color = "#f87171";
      }
    });
    
    // Load saved student name
    hubStudentName.value = localStorage.getItem("musicHubStudentName") || "";
    
    // Load submissions from server
    async function loadHubSubmissions(){
      const url = hubServerUrl.value.trim();
      
      if(!url){
        hubProjectList.innerHTML = '<div style="color:#f87171;text-align:center;padding:20px;">Set server URL first</div>';
        hubConnectionStatus.textContent = "No server URL set";
        hubConnectionStatus.style.color = "#f87171";
        return;
      }
      
      hubProjectList.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px;">Loading...</div>';
      
      try {
        const res = await fetch(url);
        const result = await res.json();
        
        if(result.success){
          hubProjects = result.submissions || [];
          hubConnectionStatus.textContent = `Connected`;
          hubConnectionStatus.style.color = "#4ade80";
          renderHubProjects();
        } else {
          hubProjectList.innerHTML = `<div style="color:#f87171;text-align:center;padding:20px;">Error: ${result.error}</div>`;
        }
      } catch(e){
        hubConnectionStatus.textContent = `Connection failed`;
        hubConnectionStatus.style.color = "#f87171";
        hubProjectList.innerHTML = '<div style="color:#f87171;text-align:center;padding:20px;">Cannot connect to server</div>';
      }
    }
    
    function escapeHtml(str){
      return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }
    
    function renderHubProjects(){
      hubCount.textContent = hubProjects.length;
      
      if(hubProjects.length === 0){
        hubProjectList.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px;">No submissions yet</div>';
        return;
      }
      
      // Sort by time (newest first)
      const sorted = [...hubProjects].sort((a, b) => (b.time || 0) - (a.time || 0));
      
      hubProjectList.innerHTML = sorted.map((s, i) => {
        const origIndex = hubProjects.indexOf(s);
        const time = s.time ? new Date(s.time).toLocaleTimeString() : '';
        // Count loops
        let loopCount = 0;
        if(s.data && s.data.slots){
          loopCount = s.data.slots.filter(function(sl){ return sl !== null; }).length;
        } else if(s.data && s.data.dr){
          loopCount = 1; // Old format - single pattern
        }
        return '<div style="display:flex;align-items:center;gap:8px;padding:10px;background:var(--card);border-radius:8px;margin-bottom:6px;" id="hubItem' + origIndex + '">' +
          '<span style="font-size:16px;color:var(--muted);">' + loopCount + '</span>' +
          '<div style="flex:1;min-width:0;">' +
            '<div style="font-weight:bold;color:var(--text);overflow:hidden;text-overflow:ellipsis;">' + escapeHtml(s.name) + '</div>' +
            '<div style="font-size:10px;color:var(--muted);">' + time + '</div>' +
          '</div>' +
          '<button onclick="playHubProject(' + origIndex + ')" style="padding:8px 16px;background:#22c55e;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;">Play</button>' +
        '</div>';
      }).join('');
    }
    
    // Play a specific hub project (all slots)
    window.playHubProject = async function(index){
      const project = hubProjects[index];
      if(!project) return;
      
      hubPlaying = true;
      hubPlayIndex = index;
      
      await resumeAudio();
      ensureSynths();
      
      // Parse slots - handle both new format (slots array) and old format (single pattern)
      var projectSlots = [];
      if(project.data && project.data.slots){
        for(var i = 0; i < project.data.slots.length; i++){
          if(project.data.slots[i]){
            projectSlots.push(parseProjectData(project.data.slots[i]));
          }
        }
      } else if(project.data){
        // Old format - single pattern
        var parsed = parseProjectData(project.data);
        if(parsed) projectSlots.push(parsed);
      }
      
      if(projectSlots.length === 0) return;
      
      stopLoopPlayback();
      hubModal.style.display = "none";
      showStudentName(project.name);
      
      // Play through all slots with continuous timing
      var currentSlotIndex = 0;
      var barsPlayed = 0;
      var step = 0;
      var nextTime = ctx.currentTime + 0.02;
      var hubTimer = null;
      var currentPattern = projectSlots[0];
      
      applyProjectMixer(currentPattern);
      loopSlots[0] = currentPattern;
      setStatus(project.name + " - Loop 1/" + projectSlots.length);
      
      function scheduleSlotStep(){
        if(!hubPlaying){
          hideStudentName();
          if(hubTimer) clearTimeout(hubTimer);
          return;
        }
        
        var stepDur = sixteenthSec();
        var statusMsg = null;
        var finished = false;
        
        while(nextTime < ctx.currentTime + 0.1){
          playLoopStep(currentPattern, step, nextTime);
          
          step++;
          if(step >= 16){
            step = 0;
            barsPlayed++;
            statusMsg = project.name + " - Loop " + (currentSlotIndex + 1) + "/" + projectSlots.length + " - Bar " + barsPlayed + "/4";
            
            if(barsPlayed >= 4){
              barsPlayed = 0;
              currentSlotIndex++;
              
              if(currentSlotIndex >= projectSlots.length){
                finished = true;
                break;
              }
              
              // Switch to next slot without resetting timing
              currentPattern = projectSlots[currentSlotIndex];
              loopSlots[0] = currentPattern;
              applyProjectMixer(currentPattern);
              statusMsg = project.name + " - Loop " + (currentSlotIndex + 1) + "/" + projectSlots.length;
            }
          }
          nextTime += stepDur;
        }
        
        // UI updates after audio scheduling
        if(statusMsg) setStatus(statusMsg);
        
        if(finished){
          hubPlaying = false;
          hideStudentName();
          setStatus("Finished: " + project.name);
          if(hubTimer) clearTimeout(hubTimer);
          return;
        }
        
        hubTimer = setTimeout(scheduleSlotStep, 20);
      }
      
      scheduleSlotStep();
    };
    
    // Apply mixer settings from project data
    function applyProjectMixer(data){
      if(!data) return;
      
      const m = (data.params && data.params.mixer) || {};
      const mt = (data.params && data.params.mutes) || {};
      
      // Update slider values
      if(isFinite(m.dV)) mDrumVolEl.value = m.dV;
      if(isFinite(m.bV)) mBassVolEl.value = m.bV;
      if(isFinite(m.lV)) mLeadVolEl.value = m.lV;
      if(isFinite(m.dF)) mDrumLPFEl.value = m.dF;
      if(isFinite(m.bF)) mBassLPFEl.value = m.bF;
      if(isFinite(m.lF)) mLeadLPFEl.value = m.lF;
      
      // Update mute object (this is what applyMixerNow uses)
      mute.drums = !!mt.drum;
      mute.bass = !!mt.bass;
      mute.lead = !!mt.lead;
      
      // Update mute button UI
      mDrumMuteBtn.classList.toggle("on", mute.drums);
      mDrumMuteBtn.textContent = mute.drums ? "Muted" : "Mute";
      mBassMuteBtn.classList.toggle("on", mute.bass);
      mBassMuteBtn.textContent = mute.bass ? "Muted" : "Mute";
      mLeadMuteBtn.classList.toggle("on", mute.lead);
      mLeadMuteBtn.textContent = mute.lead ? "Muted" : "Mute";
      
      // Apply to audio nodes
      if(ctx) applyMixerNow(true);
    }
    
    // Big student name display
    function showStudentName(name){
      let overlay = document.getElementById("studentNameOverlay");
      if(!overlay){
        overlay = document.createElement("div");
        overlay.id = "studentNameOverlay";
        overlay.style.cssText = `
          position: fixed;
          top: 50px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(135deg, #8b5cf6, #3b82f6);
          color: white;
          padding: 16px 40px;
          border-radius: 50px;
          font-size: 28px;
          font-weight: 900;
          z-index: 1000;
          box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          animation: popIn 0.3s ease;
        `;
        document.body.appendChild(overlay);
        
        // Add animation style
        if(!document.getElementById("studentNameStyle")){
          const style = document.createElement("style");
          style.id = "studentNameStyle";
          style.textContent = `
            @keyframes popIn {
              0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
              100% { transform: translateX(-50%) scale(1); opacity: 1; }
            }
          `;
          document.head.appendChild(style);
        }
      }
      overlay.textContent = name;
      overlay.style.display = "block";
    }
    
    function hideStudentName(){
      const overlay = document.getElementById("studentNameOverlay");
      if(overlay) overlay.style.display = "none";
    }
    
    // Stop playback
    hubStopBtn.addEventListener("click", () => {
      hubPlaying = false;
      hubPlayIndex = -1;
      stopLoopPlayback();
      hideStudentName();
      setStatus("Stopped");
    });
    
    // Play all projects in sequence
    hubPlayAllBtn.addEventListener("click", async () => {
      if(hubProjects.length === 0){
        alert("No submissions to play!");
        return;
      }
      
      hubPlaying = true;
      hubPlayIndex = 0;
      hubModal.style.display = "none";
      playNextHubProject();
    });
    
    async function playNextHubProject(){
      if(!hubPlaying || hubPlayIndex >= hubProjects.length){
        hubPlaying = false;
        hubPlayIndex = -1;
        stopLoopPlayback();
        hideStudentName();
        setStatus("Finished playing all!");
        return;
      }
      
      const project = hubProjects[hubPlayIndex];
      
      await resumeAudio();
      ensureSynths();
      
      // Parse slots - handle both new format (slots array) and old format (single pattern)
      var projectSlots = [];
      if(project.data && project.data.slots){
        for(var i = 0; i < project.data.slots.length; i++){
          if(project.data.slots[i]){
            projectSlots.push(parseProjectData(project.data.slots[i]));
          }
        }
      } else if(project.data){
        var parsed = parseProjectData(project.data);
        if(parsed) projectSlots.push(parsed);
      }
      
      if(projectSlots.length === 0){
        hubPlayIndex++;
        playNextHubProject();
        return;
      }
      
      showStudentName(project.name + " (" + (hubPlayIndex + 1) + "/" + hubProjects.length + ")");
      
      // Play through all slots for this project
      var currentSlotIndex = 0;
      var barsPlayed = 0;
      var step = 0;
      var nextTime = ctx.currentTime + 0.05;
      var hubTimer = null;
      
      function playCurrentSlotInAll(){
        if(!hubPlaying){
          hideStudentName();
          return;
        }
        
        if(currentSlotIndex >= projectSlots.length){
          // Move to next project
          hubPlayIndex++;
          setTimeout(playNextHubProject, 200);
          return;
        }
        
        var currentPattern = projectSlots[currentSlotIndex];
        loopSlots[0] = currentPattern;
        applyProjectMixer(currentPattern);
        
        barsPlayed = 0;
        step = 0;
        nextTime = ctx.currentTime + 0.02;
        
        var totalLoops = projectSlots.length;
        setStatus(project.name + " (" + (hubPlayIndex + 1) + "/" + hubProjects.length + ") - Loop " + (currentSlotIndex + 1) + "/" + totalLoops);
        
        function scheduleSlotStepInAll(){
          if(!hubPlaying){
            hideStudentName();
            if(hubTimer) clearTimeout(hubTimer);
            return;
          }
          
          var stepDur = sixteenthSec();
          var statusMsg = null;
          var switchToNext = false;
          
          while(nextTime < ctx.currentTime + 0.1){
            playLoopStep(currentPattern, step, nextTime);
            
            step++;
            if(step >= 16){
              step = 0;
              barsPlayed++;
              statusMsg = project.name + " (" + (hubPlayIndex + 1) + "/" + hubProjects.length + ") - Loop " + (currentSlotIndex + 1) + "/" + totalLoops + " - Bar " + barsPlayed + "/4";
              
              if(barsPlayed >= 4){
                barsPlayed = 0;
                currentSlotIndex++;
                
                if(currentSlotIndex >= projectSlots.length){
                  // All slots done, move to next project
                  switchToNext = true;
                  break;
                }
                
                // Switch to next slot seamlessly
                currentPattern = projectSlots[currentSlotIndex];
                loopSlots[0] = currentPattern;
                applyProjectMixer(currentPattern);
                statusMsg = project.name + " (" + (hubPlayIndex + 1) + "/" + hubProjects.length + ") - Loop " + (currentSlotIndex + 1) + "/" + totalLoops;
              }
            }
            nextTime += stepDur;
          }
          
          // UI update after audio scheduling
          if(statusMsg) setStatus(statusMsg);
          
          if(switchToNext){
            hubPlayIndex++;
            if(hubTimer) clearTimeout(hubTimer);
            setTimeout(playNextHubProject, 200);
            return;
          }
          
          hubTimer = setTimeout(scheduleSlotStepInAll, 20);
        }
        
        scheduleSlotStepInAll();
      }
      
      playCurrentSlotInAll();
    }
    
    // Clear all submissions
    hubClearAllBtn.addEventListener("click", async () => {
      if(!confirm("Clear ALL submissions?")) return;
      
      const url = hubServerUrl.value.trim();
      if(!url) return;
      
      try {
        await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'clear' })
        });
        loadHubSubmissions();
      } catch(e){}
    });
    
    hubRefreshBtn.addEventListener("click", loadHubSubmissions);
    
    hubBtn.addEventListener("click", () => {
      hubModal.style.display = "flex";
      if(hubServerUrl.value.trim()) loadHubSubmissions();
    });
    
    closeHubBtn.addEventListener("click", () => {
      hubModal.style.display = "none";
    });
    
    hubModal.addEventListener("click", (e) => {
      if(e.target === hubModal) hubModal.style.display = "none";
    });

    // ---------- audio ----------
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let ctx = null;

    let master=null, limiter=null, hp=null;
    let drumBus=null, bassBus=null, leadBus=null;
    let drumGain=null, bassGain=null, leadGain=null;
    let drumLPF=null, bassLPF=null, leadLPF=null;
    let bassDuckGain=null, leadDuckGain=null;

    let recDest=null;

    const trackGains = new Map();

    function ensureAudio(){
      if(ctx) return;
      ctx = new AudioCtx();

      master = ctx.createGain();
      master.gain.value = clamp(parseFloat(masterVolEl.value||0.9),0,1);

      limiter = ctx.createDynamicsCompressor();
      limiter.threshold.value = -8;
      limiter.knee.value = 8;
      limiter.ratio.value = 6;
      limiter.attack.value = 0.003;
      limiter.release.value = 0.22;

      hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 25;

      drumBus = ctx.createGain();
      bassBus = ctx.createGain();
      leadBus = ctx.createGain();

      drumLPF = ctx.createBiquadFilter(); drumLPF.type="lowpass";
      bassLPF = ctx.createBiquadFilter(); bassLPF.type="lowpass";
      leadLPF = ctx.createBiquadFilter(); leadLPF.type="lowpass";

      drumGain = ctx.createGain();
      bassGain = ctx.createGain();
      leadGain = ctx.createGain();

      bassDuckGain = ctx.createGain(); bassDuckGain.gain.value = 1;
      leadDuckGain = ctx.createGain(); leadDuckGain.gain.value = 1;

      drumBus.connect(drumLPF); drumLPF.connect(drumGain); drumGain.connect(master);

      bassBus.connect(bassDuckGain);
      bassDuckGain.connect(bassLPF);
      bassLPF.connect(bassGain);
      bassGain.connect(master);

      leadBus.connect(leadDuckGain);
      leadDuckGain.connect(leadLPF);
      leadLPF.connect(leadGain);
      leadGain.connect(master);

      recDest = ctx.createMediaStreamDestination();

      master.connect(limiter);
      limiter.connect(recDest);
      limiter.connect(hp);
      hp.connect(ctx.destination);

      applyMixerNow(true);
    }

    async function resumeAudio(){
      ensureAudio();
      try{ await ctx.resume(); }catch(_){}
    }

    bindInput(masterVolEl, () => {
      if(master) master.gain.value = clamp(parseFloat(masterVolEl.value||0.9),0,1);
      scheduleSave();
    });

    // ---------- mixer ----------
    const mDrumVolEl = document.getElementById("mDrumVol");
    const mBassVolEl = document.getElementById("mBassVol");
    const mLeadVolEl = document.getElementById("mLeadVol");

    const mDrumLPFEl = document.getElementById("mDrumLPF");
    const mBassLPFEl = document.getElementById("mBassLPF");
    const mLeadLPFEl = document.getElementById("mLeadLPF");

    const mDrumMuteBtn = document.getElementById("mDrumMute");
    const mBassMuteBtn = document.getElementById("mBassMute");
    const mLeadMuteBtn = document.getElementById("mLeadMute");

    const sidechainAmtEl = document.getElementById("sidechainAmt");
    const sidechainValEl = document.getElementById("sidechainVal");
    sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);

    const mute = { drums:false, bass:false, lead:false };

    function sideAmt(){ return clamp(parseFloat(sidechainAmtEl.value||0),0,1); }
    function volFromFader(v){ return clamp(+v||0, 0, 1); }
    function cutoffFromLPFFader(v){
      v = clamp(+v||0, 0, 1);
      return expMap01(v, 30, 20000);
    }

    function applyMixerNow(instant=false){
      if(!ctx || !drumGain || !bassGain || !leadGain) return;
      const t = ctx.currentTime;
      const tau = instant ? 0.001 : 0.02;

      const drumVol = mute.drums ? 0 : volFromFader(mDrumVolEl.value);
      const bassVol = mute.bass ? 0 : volFromFader(mBassVolEl.value);
      const leadVol = mute.lead ? 0 : volFromFader(mLeadVolEl.value);

      drumGain.gain.setTargetAtTime(drumVol, t, tau);
      bassGain.gain.setTargetAtTime(bassVol, t, tau);
      leadGain.gain.setTargetAtTime(leadVol, t, tau);

      if(drumLPF) drumLPF.frequency.setTargetAtTime(cutoffFromLPFFader(mDrumLPFEl.value), t, tau);
      if(bassLPF) bassLPF.frequency.setTargetAtTime(cutoffFromLPFFader(mBassLPFEl.value), t, tau);
      if(leadLPF) leadLPF.frequency.setTargetAtTime(cutoffFromLPFFader(mLeadLPFEl.value), t, tau);

      if(drumLPF) drumLPF.Q.setTargetAtTime(0.55, t, tau);
      if(bassLPF) bassLPF.Q.setTargetAtTime(0.60, t, tau);
      if(leadLPF) leadLPF.Q.setTargetAtTime(0.55, t, tau);
    }

    function hookMixer(){
      const mixerUpdate = () => {
        if(ctx) applyMixerNow(false);
        scheduleSave();
      };

      [mDrumVolEl,mBassVolEl,mLeadVolEl,mDrumLPFEl,mBassLPFEl,mLeadLPFEl].forEach(el => bindInput(el, mixerUpdate));

      bindInput(sidechainAmtEl, () => {
        sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);
        scheduleSave();
      });

      function toggleMute(which, btn){
        mute[which] = !mute[which];
        btn.classList.toggle("on", mute[which]);
        btn.textContent = mute[which] ? "Muted" : "Mute";
        if(ctx) applyMixerNow(false);
        scheduleSave();
      }
      mDrumMuteBtn.addEventListener("click", () => toggleMute("drums", mDrumMuteBtn));
      mBassMuteBtn.addEventListener("click", () => toggleMute("bass", mBassMuteBtn));
      mLeadMuteBtn.addEventListener("click", () => toggleMute("lead", mLeadMuteBtn));
    }

    function triggerSidechain(time){
      if(!ctx || !bassDuckGain || !leadDuckGain) return;
      const amt = sideAmt();
      if(amt <= 0.0001) return;

      const minGainB = 1 - (amt * 0.55);
      const minGainL = 1 - (amt * 0.40);
      const atk = 0.008;
      const rel = 0.22;

      bassDuckGain.gain.cancelScheduledValues(time);
      bassDuckGain.gain.setValueAtTime(bassDuckGain.gain.value, time);
      bassDuckGain.gain.setTargetAtTime(minGainB, time, atk);
      bassDuckGain.gain.setTargetAtTime(1.0, time + 0.03, rel);

      leadDuckGain.gain.cancelScheduledValues(time);
      leadDuckGain.gain.setValueAtTime(leadDuckGain.gain.value, time);
      leadDuckGain.gain.setTargetAtTime(minGainL, time, atk);
      leadDuckGain.gain.setTargetAtTime(1.0, time + 0.03, rel);
    }

    // ---------- delay FX ----------
    function makeDelayFX({ mixEl, fbEl }, destBus){
      const dry = ctx.createGain();
      const wetIn = ctx.createGain();
      const delay = ctx.createDelay(2.0);
      const fb = ctx.createGain();
      const wetOut = ctx.createGain();

      wetIn.connect(delay);
      delay.connect(wetOut);
      wetOut.connect(destBus);

      delay.connect(fb);
      fb.connect(delay);

      dry.connect(destBus);

      function update(instant=false){
        const t = ctx.currentTime;
        const dt = dotted8Sec();
        const mix = clamp(parseFloat(mixEl.value||0), 0, 1);
        const fbb = clamp(parseFloat(fbEl.value||0), 0, 0.75);
        const tau = instant ? 0.001 : 0.02;

        delay.delayTime.setTargetAtTime(dt, t, tau);
        fb.gain.setTargetAtTime(fbb, t, tau);
        dry.gain.setTargetAtTime(1 - mix, t, tau);
        wetIn.gain.setTargetAtTime(mix, t, tau);
      }

      update(true);
      return { dry, wetIn, update };
    }

    // ---------- drum machine ----------
    const headerRow = document.getElementById("headerRow");
    const gridEl = document.getElementById("grid");
    const clearBtn = document.getElementById("clear");

    const s1RecBtn   = document.getElementById("s1RecBtn");
    const s1PlayBtn  = document.getElementById("s1PlayBtn");
    const s1ClearBtn = document.getElementById("s1ClearBtn");
    const s1Status   = document.getElementById("s1Status");
    const s1MixEl    = document.getElementById("s1Mix");
    const s1FbEl     = document.getElementById("s1Fb");
    const s1PitchEl  = document.getElementById("s1Pitch");
    const s1PitchVal = document.getElementById("s1PitchVal");

    const s2RecBtn   = document.getElementById("s2RecBtn");
    const s2PlayBtn  = document.getElementById("s2PlayBtn");
    const s2ClearBtn = document.getElementById("s2ClearBtn");
    const s2Status   = document.getElementById("s2Status");
    const s2MixEl    = document.getElementById("s2Mix");
    const s2FbEl     = document.getElementById("s2Fb");
    const s2PitchEl  = document.getElementById("s2Pitch");
    const s2PitchVal = document.getElementById("s2PitchVal");

    function fmtPitch(v){
      v = Math.max(-12, Math.min(12, (v|0)));
      const sign = (v >= 0) ? "+" : "-";
      const n = String(Math.abs(v)).padStart(2,"0");
      return sign + n;
    }

    const STEPS = 16;
    const activeSources = new Set();

    const TRACKS_DEF = [
      { name:"Kick",     key:"kick",     colorClass:"t1" },
      { name:"Snare",    key:"snare",    colorClass:"t2" },
      { name:"Hi-Hat",   key:"hat",      colorClass:"t3" },
      { name:"Open Hat", key:"openhat",  colorClass:"t7" },
      { name:"Clap",     key:"clap",     colorClass:"t4" },
      { name:"Perc",     key:"perc",     colorClass:"t5" },
      { name:"Sample 1", key:"sample1",  colorClass:"t6", isSampler:true, samplerId:1 },
      { name:"Sample 2", key:"sample2",  colorClass:"t8", isSampler:true, samplerId:2 },
    ];

    let tracks = TRACKS_DEF.map(t => ({
      ...t,
      fileLabel: t.isSampler ? "No sample" : "Loading…",
      buffer: null,
      pattern: Array(STEPS).fill(false),
      vol: 0.85
    }));

    const tracksByKey = new Map();
    function rebuildTracksByKey(){
      tracksByKey.clear();
      for(const tr of tracks) tracksByKey.set(tr.key, tr);
    }
    rebuildTracksByKey();

    const sample1Track = tracks.find(t => t.key === "sample1");
    const sample2Track = tracks.find(t => t.key === "sample2");

    function ensureTrackGain(key){
      if(!ctx) return null;
      if(trackGains.has(key)) return trackGains.get(key);
      const g = ctx.createGain();
      g.gain.value = 0.85;
      g.connect(drumBus);
      trackGains.set(key, g);
      return g;
    }
    function setTrackGain(key, v, instant=false){
      if(!ctx) return;
      const g = ensureTrackGain(key);
      if(!g) return;
      const t = ctx.currentTime;
      const tau = instant ? 0.001 : 0.02;
      g.gain.setTargetAtTime(clamp(v,0,1), t, tau);
    }

    function playBufferAt(buf, time, destination){
      if(!ctx || !destination || !buf) return;
      const src = ctx.createBufferSource();
      src.buffer = buf;
      src.connect(destination);
      activeSources.add(src);
      src.onended = () => activeSources.delete(src);
      try{ src.start(time); }catch(_){}
      return src;
    }

    function hardStopAllSources(){
      for(const src of Array.from(activeSources)){
        try{ src.stop(0); }catch(_){}
        activeSources.delete(src);
      }
    }

    // build-once UI
    const cellRefsByTrack = new Map();
    let lastPlayStep = -1;

    function buildHeader(){
      headerRow.innerHTML = "";
      const left = document.createElement("div");
      left.className = "headerCell";
      left.textContent = "Sounds";
      headerRow.appendChild(left);

      for(let s=0;s<16;s++){
        const d = document.createElement("div");
        d.className="headerCell";
        d.textContent = (s%4===0) ? String((s/4)+1) : "";
        headerRow.appendChild(d);
      }
    }

    function toggleCellUI(trackKey, step, on){
      const arr = cellRefsByTrack.get(trackKey);
      if(!arr) return;
      const cell = arr[step];
      if(!cell) return;

      const tr = tracksByKey.get(trackKey);
      if(!tr) return;

      cell.classList.toggle("on", on);
      if(on) cell.classList.add(tr.colorClass);
      else cell.classList.remove(tr.colorClass);
    }

    function setPlayheadUI(step){
      if(step === lastPlayStep) return;

      if(lastPlayStep >= 0){
        for(const arr of cellRefsByTrack.values()){
          const c = arr[lastPlayStep];
          if(c) c.classList.remove("playhead");
        }
      }
      for(const arr of cellRefsByTrack.values()){
        const c = arr[step];
        if(c) c.classList.add("playhead");
      }
      lastPlayStep = step;
    }

    function clearPlayheadUI(){
      if(lastPlayStep < 0) return;
      for(const arr of cellRefsByTrack.values()){
        const c = arr[lastPlayStep];
        if(c) c.classList.remove("playhead");
      }
      lastPlayStep = -1;
    }

    function listenFastTap(el, handler){
      el.addEventListener("pointerdown", (e) => {
        if(e.pointerType === "mouse" && e.button !== 0) return;
        e.preventDefault();
        handler(e);
      }, {passive:false});
    }

    function buildGridOnce(){
      gridEl.innerHTML = "";
      cellRefsByTrack.clear();

      for(const tr of tracks){
        const row = document.createElement("div");
        row.className = "row";

        const trackCell = document.createElement("div");
        trackCell.className = "trackCell";

        const left = document.createElement("div");
        left.className = "trackLeft";

        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = (getComputedStyle(document.documentElement).getPropertyValue(`--${tr.colorClass}`).trim() || "#ccc");
        left.appendChild(sw);

        const text = document.createElement("div");
        text.className = "trackText";

        const name = document.createElement("div");
        name.className = "trackName";
        name.textContent = tr.name;

        const file = document.createElement("div");
        file.className = "fileLabel";
        file.textContent = tr.fileLabel;

        text.appendChild(name);
        text.appendChild(file);
        left.appendChild(text);

        trackCell.appendChild(left);

        const volWrap = document.createElement("div");
        volWrap.className = "trkVol";
        const vol = document.createElement("input");
        vol.type="range"; vol.min="0"; vol.max="1"; vol.step="0.01";
        vol.value = String(clamp(tr.vol ?? 0.85, 0, 1));

        let pendingVol = null;
        let volRAF = 0;
        const commitVol = () => {
          volRAF = 0;
          if(pendingVol == null) return;
          tr.vol = pendingVol;
          if(ctx) setTrackGain(tr.key, tr.vol, false);
          pendingVol = null;
        };
        const onVolInput = () => {
          pendingVol = clamp(parseFloat(vol.value||"0.85"), 0, 1);
          if(!volRAF) volRAF = requestAnimationFrame(commitVol);
          scheduleSave();
        };
        vol.addEventListener("input", onVolInput, {passive:true});
        vol.addEventListener("change", onVolInput, {passive:true});
        volWrap.appendChild(vol);

        trackCell.appendChild(volWrap);
        row.appendChild(trackCell);

        const refs = new Array(16);

        for(let s=0;s<16;s++){
          const cell = document.createElement("div");
          cell.className = "cell" + ((((s+1)%2)?" alt":""));
          if(tr.pattern[s]){ cell.classList.add("on", tr.colorClass); }

          cell.dataset.track = tr.key;
          cell.dataset.step = String(s);

          listenFastTap(cell, async () => {
            tr.pattern[s] = !tr.pattern[s];
            toggleCellUI(tr.key, s, tr.pattern[s]);

            await resumeAudio();

            if(tr.pattern[s]){
              const g = ensureTrackGain(tr.key);
              setTrackGain(tr.key, tr.vol, true);

              if(tr.isSampler){
                if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
                if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
              }else if(tr.buffer){
                playBufferAt(tr.buffer, ctx.currentTime, g);
              }
            }
            scheduleSave();
          });

          refs[s] = cell;
          row.appendChild(cell);
        }

        cellRefsByTrack.set(tr.key, refs);
        gridEl.appendChild(row);

        tr._ui = { fileEl: file, nameEl: name, volEl: vol };
      }
    }

    function updateTrackLabels(){
      for(const tr of tracks){
        if(tr._ui?.fileEl) tr._ui.fileEl.textContent = tr.fileLabel;
        if(tr._ui?.nameEl) tr._ui.nameEl.textContent = tr.name;
        if(tr._ui?.volEl) tr._ui.volEl.value = String(clamp(tr.vol ?? 0.85, 0, 1));
      }
    }

    // Sample play with delay
    function playSampleNow(which, time){
      const tr = (which===1) ? sample1Track : sample2Track;
      if(!tr.buffer || !ctx) return;

      const g = ensureTrackGain(tr.key);
      setTrackGain(tr.key, tr.vol, true);

      const t = (typeof time === "number") ? time : ctx.currentTime;

      const src = ctx.createBufferSource();
      src.buffer = tr.buffer;

      const semis = (which===1 ? (+s1PitchEl.value||0) : (+s2PitchEl.value||0));
      src.playbackRate.setValueAtTime(Math.pow(2, semis/12), t);

      const delay = ctx.createDelay(2.0);
      const fb = ctx.createGain();
      const wetOut = ctx.createGain();
      const wetIn = ctx.createGain();
      const dry = ctx.createGain();

      delay.delayTime.setValueAtTime(quarterSec(), t);
      fb.gain.setValueAtTime(clamp(parseFloat((which===1?s1FbEl.value:s2FbEl.value)||0),0,0.75), t);

      const mix = clamp(parseFloat((which===1?s1MixEl.value:s2MixEl.value)||0),0,1);
      dry.gain.setValueAtTime(1-mix, t);
      wetIn.gain.setValueAtTime(mix, t);

      src.connect(dry);
      src.connect(wetIn);

      wetIn.connect(delay);
      delay.connect(wetOut);
      wetOut.connect(g);
      dry.connect(g);

      delay.connect(fb);
      fb.connect(delay);

      activeSources.add(src);
      src.onended = () => activeSources.delete(src);
      try{ src.start(t); }catch(_){}
    }

    function setSamplerUI(which, has){
      const is1 = which === 1;
      const playBtn = is1 ? s1PlayBtn : s2PlayBtn;
      const clrBtn  = is1 ? s1ClearBtn : s2ClearBtn;
      const status  = is1 ? s1Status : s2Status;
      const tr      = is1 ? sample1Track : sample2Track;

      playBtn.disabled = !has;
      clrBtn.disabled  = !has;

      if(!has){
        status.textContent = "No sample";
        tr.fileLabel = "No sample";
      }else{
        status.textContent = "Sample ready ";
        tr.fileLabel = "Recorded";
      }
      updateTrackLabels();
    }
    setSamplerUI(1,false);
    setSamplerUI(2,false);

    let _rec=null, _chunks=[], _stream=null, _recWhich=1;

    function applyTinyFade(buf, fadeMs=2){
      if(!buf || !ctx) return buf;
      const sr = buf.sampleRate;
      const n = Math.max(1, Math.floor(sr*(fadeMs/1000)));
      for(let c=0;c<buf.numberOfChannels;c++){
        const d = buf.getChannelData(c);
        const L = d.length;
        const nn = Math.min(n, Math.floor(L/2));
        for(let i=0;i<nn;i++){
          const g = (nn<=1) ? 1 : (i/(nn-1));
          d[i] *= g;
          d[L-1-i] *= g;
        }
      }
      return buf;
    }

    function trimBufferPrecise(buf, {thr=0.018, minRunMs=2.0, prerollMs=6.0, tailThr=0.012, tailHoldMs=25.0} = {}){
      const sr = buf.sampleRate;
      const len = buf.length;
      const ch0 = buf.getChannelData(0);

      const minRun = Math.max(1, Math.floor(sr*(minRunMs/1000)));
      const preroll = Math.floor(sr*(prerollMs/1000));
      const tailHold = Math.max(1, Math.floor(sr*(tailHoldMs/1000)));

      let start=0, run=0, found=false;
      for(let i=0;i<len;i++){
        const a = Math.abs(ch0[i]);
        if(a >= thr){
          run++;
          if(run >= minRun){
            start = Math.max(0, i - run + 1 - preroll);
            found = true;
            break;
          }
        }else run = 0;
      }
      if(!found) return buf;

      let end=len;
      let quietRun=0;
      for(let i=len-1;i>=0;i--){
        const a = Math.abs(ch0[i]);
        if(a < tailThr){
          quietRun++;
          if(quietRun >= tailHold){
            end = Math.min(len, i + quietRun);
            break;
          }
        }else quietRun = 0;
      }

      const minKeep = Math.floor(sr*0.06);
      if(end - start < minKeep) end = Math.min(len, start + minKeep);

      start = Math.max(0, Math.min(start, len-1));
      end = Math.max(start+1, Math.min(end, len));

      const outLen = end - start;
      const out = ctx.createBuffer(buf.numberOfChannels, outLen, sr);
      for(let c=0;c<buf.numberOfChannels;c++){
        const src = buf.getChannelData(c);
        const dst = out.getChannelData(c);
        dst.set(src.subarray(start, end));
      }
      return out;
    }

    async function recordSample2s(which){
      await resumeAudio();

      if(!navigator.mediaDevices?.getUserMedia){
        alert("Microfoon werkt niet in deze browser.");
        return;
      }
      if(_rec && _rec.state === "recording") return;

      _recWhich = which;
      (which===1 ? s1Status : s2Status).textContent = "Recording…";
      (which===1 ? s1PlayBtn : s2PlayBtn).disabled = true;
      (which===1 ? s1ClearBtn : s2ClearBtn).disabled = true;

      try{
        _stream = await navigator.mediaDevices.getUserMedia({
          audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true }
        });

        _chunks = [];
        _rec = new MediaRecorder(_stream);

        _rec.ondataavailable = (e)=>{ if(e.data && e.data.size) _chunks.push(e.data); };

        _rec.onstop = async ()=>{
          const tr = (_recWhich===1) ? sample1Track : sample2Track;
          try{
            const blob = new Blob(_chunks, { type: _rec.mimeType || "audio/webm" });
            const arr = await blob.arrayBuffer();
            const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
            const trimmed = trimBufferPrecise(buf, {});
            tr.buffer = applyTinyFade(trimmed, 2);
            setSamplerUI(_recWhich, true);
            scheduleSave();
          }catch(err){
            console.error(err);
            tr.buffer = null;
            setSamplerUI(_recWhich, false);
            (tr===sample1Track ? s1Status : s2Status).textContent = "Sample failed";
          }finally{
            if(_stream) _stream.getTracks().forEach(t=>t.stop());
            _stream = null;
          }
        };

        _rec.start();
        setTimeout(()=>{ if(_rec && _rec.state === "recording"){ try{ _rec.stop(); }catch(_){}} }, 2000);

      }catch(err){
        console.error(err);
        (which===1 ? s1Status : s2Status).textContent = "Mic blocked";
        setSamplerUI(which, false);
      }
    }

    function clearSample(which){
      const tr = (which===1) ? sample1Track : sample2Track;
      tr.buffer = null;
      setSamplerUI(which, false);
      scheduleSave();
    }

    bindInput(s1PitchEl, ()=>{ s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0); scheduleSave(); });
    bindInput(s2PitchEl, ()=>{ s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0); scheduleSave(); });
    s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
    s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);

    s1RecBtn.addEventListener("click", ()=>recordSample2s(1));
    s2RecBtn.addEventListener("click", ()=>recordSample2s(2));
    s1PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(1, ctx.currentTime); });
    s2PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(2, ctx.currentTime); });
    s1ClearBtn.addEventListener("click", ()=>clearSample(1));
    s2ClearBtn.addEventListener("click", ()=>clearSample(2));

    async function fetchArrayBuffer(url){
      const r = await fetch(url, { cache:"no-store" });
      if(!r.ok) throw new Error("HTTP " + r.status);
      return await r.arrayBuffer();
    }

    async function loadOneTrack(tr){
      tr.buffer = null;
      tr.fileLabel = "Missing file";
      updateTrackLabels();
      for(const ext of ["wav","mp3","ogg"]){
        const url = "./samples/" + tr.key + "." + ext;
        try{
          const arr = await fetchArrayBuffer(url);
          const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
          tr.buffer = buf;
          tr.fileLabel = tr.key + "." + ext;
          updateTrackLabels();
          return true;
        }catch(_){}
      }
      updateTrackLabels();
      return false;
    }

    async function loadAllSounds(){
      await resumeAudio();
      setStatus("Loading sounds…");

      let ok = 0;
      for(const tr of tracks){
        if(tr.isSampler){
          tr.fileLabel = tr.buffer ? "Recorded" : "No sample";
          continue;
        }
        if(await loadOneTrack(tr)) ok++;
      }
      setStatus(ok ? `Ready (${ok}/${tracks.filter(t=>!t.isSampler).length}).` : "No sounds loaded (check ./samples filenames).");
      updateTrackLabels();
    }

    clearBtn.addEventListener("click", () => {
      for(const tr of tracks){
        tr.pattern.fill(false);
        const refs = cellRefsByTrack.get(tr.key);
        if(refs){
          for(let s=0;s<16;s++){
            refs[s].classList.remove("on", tr.colorClass);
          }
        }
      }
      scheduleSave();
      setStatus("");
    });

    // ---------- bass + lead sequencers (A NATURAL MINOR) ----------
    const bassResetBtn = document.getElementById("bassReset");
    const leadResetBtn = document.getElementById("leadReset");

    const cutEl = document.getElementById("cutoff");
    const resEl = document.getElementById("reso");
    const envEl = document.getElementById("env");
    const bDecayEl = document.getElementById("bDecay");
    const dMixEl = document.getElementById("dMix");
    const dFbEl  = document.getElementById("dFb");

    const lCutEl = document.getElementById("lCutoff");
    const lResEl = document.getElementById("lReso");
    const lEnvEl = document.getElementById("lEnv");
    const lGateEl= document.getElementById("lGate");
    const lMixEl = document.getElementById("lMix");
    const lFbEl  = document.getElementById("lFb");

    const tbGridEl   = document.getElementById("tb_grid");
    const leadGridEl = document.getElementById("lead_grid");

    // A NATURAL MINOR scale (high to low): G, F, E, D, C, B, A
    // Changed from harmonic minor (G#) to natural minor (G)
    const NOTE_NAMES = ["G","F","E","D","C","B","A"];
    // Semitones from A (A=0)
    const NOTE_TO_SEMI = { "A":0, "B":2, "C":3, "D":5, "E":7, "F":8, "G":10 };

    function makeSeqState(){ return { steps: Array.from({length:16}, () => ({ note:null, oct:0 })) }; }
    let bassState = makeSeqState();
    let leadState = makeSeqState();

    function renderSeqGrid(rootEl, state, kind){
      rootEl.innerHTML = "";

      const labels = document.createElement("div");
      labels.className = "tb_labels";

      const l0 = document.createElement("div");
      l0.className = "muted";
      l0.textContent = "";
      labels.appendChild(l0);

      const l1 = document.createElement("div");
      l1.className = "muted";
      l1.textContent = "Oct";
      labels.appendChild(l1);

      const l2 = document.createElement("div");
      l2.className = "tb_spacer";
      labels.appendChild(l2);

      for(const n of NOTE_NAMES){
        const ln = document.createElement("div");
        ln.className = "muted";
        ln.style.display="flex";
        ln.style.alignItems="center";
        ln.style.justifyContent="flex-start";
        ln.textContent = n;
        labels.appendChild(ln);
      }

      rootEl.appendChild(labels);

      for(let s=0;s<16;s++){
        const col = document.createElement("div");
        col.className = "tb_col";

        const stepNum = document.createElement("div");
        stepNum.className = "tb_stepNum";
        stepNum.textContent = String(s+1);
        col.appendChild(stepNum);

        const octWrap = document.createElement("div");
        octWrap.className = "tb_oct";

        const btnTop = document.createElement("button");
        btnTop.className = "tb_octBtn oct-up";
        btnTop.textContent = "";
        btnTop.addEventListener("click", () => { state.steps[s].oct = +1; renderSeqGrid(rootEl, state, kind); scheduleSave(); });

        const btnMid = document.createElement("button");
        btnMid.className = "tb_octBtn oct-mid";
        btnMid.textContent = "";
        btnMid.addEventListener("click", () => { state.steps[s].oct = 0; renderSeqGrid(rootEl, state, kind); scheduleSave(); });

        const btnBot = document.createElement("button");
        btnBot.className = "tb_octBtn oct-down";
        btnBot.textContent = "";
        btnBot.addEventListener("click", () => { state.steps[s].oct = -1; renderSeqGrid(rootEl, state, kind); scheduleSave(); });

        btnTop.classList.toggle("on", state.steps[s].oct === +1);
        btnMid.classList.toggle("on", state.steps[s].oct === 0);
        btnBot.classList.toggle("on", state.steps[s].oct === -1);

        octWrap.appendChild(btnTop);
        octWrap.appendChild(btnMid);
        octWrap.appendChild(btnBot);
        col.appendChild(octWrap);

        const spacer = document.createElement("div");
        spacer.className = "tb_spacer";
        col.appendChild(spacer);

        for(const n of NOTE_NAMES){
          const pad = document.createElement("button");
          pad.className = "tb_pad nat";
          if(state.steps[s].note === n) pad.classList.add("on");

          pad.addEventListener("click", async () => {
            await resumeAudio();
            state.steps[s].note = (state.steps[s].note === n) ? null : n;
            renderSeqGrid(rootEl, state, kind);
            scheduleSave();
          });

          col.appendChild(pad);
        }

        rootEl.appendChild(col);
      }

      rootEl.classList.toggle("bass", kind==="bass");
      rootEl.classList.toggle("lead", kind==="lead");
    }

    // ---------- synths ----------
    let bassDelayFX=null, leadDelayFX=null;
    let bassSynth=null, leadSynth=null;

    function ensureBassLeadFX(){
      if(bassDelayFX && leadDelayFX) return;
      bassDelayFX = makeDelayFX({ mixEl:dMixEl, fbEl:dFbEl }, bassBus);
      leadDelayFX = makeDelayFX({ mixEl:lMixEl, fbEl:lFbEl }, leadBus);
    }

    function makeMonoSynth({ fat=false, baseCutMin=20, baseCutMax=12000 }){
      const input = ctx.createGain();

      const filt = ctx.createBiquadFilter();
      filt.type = "lowpass";
      filt.frequency.value = 800;
      filt.Q.value = 0.8;

      const out = ctx.createGain();
      out.gain.value = 1.0;

      input.connect(filt);
      filt.connect(out);

      function setFilter01(x, t, tau){
        x = clamp(x, 0, 1);
        const hz = expMap01(x, baseCutMin, baseCutMax);
        filt.frequency.setTargetAtTime(hz, t, tau);
      }
      function hardSetFilter01(x, t){
        x = clamp(x, 0, 1);
        const hz = expMap01(x, baseCutMin, baseCutMax);
        filt.frequency.setValueAtTime(hz, t);
      }

      function setRes01(x, t, tau){
        const xx = Math.pow(clamp(x,0,1), 1.35);
        const qMax = 14.0;
        const q = 0.5 + xx*qMax;
        filt.Q.setTargetAtTime(q, t, tau);
      }

      function trigger({ freq, time, decay=0.22, gate=0.55, envAmt=0.35, baseCut01=0.30, release=0.11, vel=1.0 }){
        // Safety checks for all params
        if(!isFinite(freq) || !isFinite(time)) return;
        freq = Math.max(20, Math.min(freq, 20000));
        decay = isFinite(decay) ? decay : 0.22;
        gate = isFinite(gate) ? gate : 0.55;
        envAmt = isFinite(envAmt) ? envAmt : 0;
        baseCut01 = isFinite(baseCut01) ? baseCut01 : 0.3;
        release = isFinite(release) ? release : 0.11;
        vel = isFinite(vel) ? vel : 1.0;
        
        const vca = ctx.createGain();
        vca.gain.setValueAtTime(0.0001, time);

        const atk = 0.003;
        const dcy = clamp(decay, 0.05, 1.20);
        const sus = clamp(gate, 0.05, 1.0);

        vca.gain.cancelScheduledValues(time);
        vca.gain.setValueAtTime(0.0001, time);
        vca.gain.linearRampToValueAtTime(vel, time + atk);
        vca.gain.setTargetAtTime(vel * sus, time + atk, dcy);
        vca.gain.setTargetAtTime(0.0001, time + atk + dcy + 0.03, release);

        const osc1 = ctx.createOscillator();
        osc1.type = "sawtooth";
        osc1.frequency.setValueAtTime(freq, time);

        let osc2 = null, osc3 = null;
        if(fat){
          osc2 = ctx.createOscillator();
          osc2.type = "sawtooth";
          osc2.frequency.setValueAtTime(freq, time);
          osc2.detune.setValueAtTime(+7, time);

          osc3 = ctx.createOscillator();
          osc3.type = "sawtooth";
          osc3.frequency.setValueAtTime(freq, time);
          osc3.detune.setValueAtTime(-7, time);
        }

        osc1.connect(vca);
        if(osc2) osc2.connect(vca);
        if(osc3) osc3.connect(vca);
        vca.connect(input);

        let env = clamp(envAmt, 0, 1);
        if(env <= 0.03) env = 0;

        const base = clamp(baseCut01, 0, 1);
        hardSetFilter01(base, time);

        if(env > 0){
          const peak = clamp(base + env*0.75, 0, 1);
          setFilter01(peak, time + 0.012, 0.015);
          setFilter01(base, time + atk + dcy + 0.05, 0.05);
        }

        const stopT = time + atk + dcy + release + 0.25;
        try{ osc1.start(time); osc1.stop(stopT); }catch(_){}
        if(osc2){ try{ osc2.start(time); osc2.stop(stopT); }catch(_){} }
        if(osc3){ try{ osc3.start(time); osc3.stop(stopT); }catch(_){} }
      }

      return { out, setFilter01, setRes01, trigger };
    }

    function ensureSynths(){
      if(bassSynth && leadSynth) return;
      ensureBassLeadFX();

      bassSynth = makeMonoSynth({ fat:false, baseCutMin:20, baseCutMax:6500 });
      leadSynth = makeMonoSynth({ fat:true,  baseCutMin:30, baseCutMax:12000 });

      bassSynth.out.connect(bassDelayFX.dry);
      bassSynth.out.connect(bassDelayFX.wetIn);

      leadSynth.out.connect(leadDelayFX.dry);
      leadSynth.out.connect(leadDelayFX.wetIn);

      bassDelayFX.update(true);
      leadDelayFX.update(true);
    }

    function applyBassParams(instant=false){
      if(!ctx || !bassSynth) return;
      const t = ctx.currentTime;
      const tau = instant ? 0.001 : 0.03;
      bassSynth.setFilter01(+cutEl.value, t, tau);
      bassSynth.setRes01(+resEl.value, t, tau);
      if(bassDelayFX) bassDelayFX.update(instant);
    }

    function applyLeadParams(instant=false){
      if(!ctx || !leadSynth) return;
      const t = ctx.currentTime;
      const tau = instant ? 0.001 : 0.03;
      leadSynth.setFilter01(+lCutEl.value, t, tau);
      leadSynth.setRes01(+lResEl.value, t, tau);
      if(leadDelayFX) leadDelayFX.update(instant);
    }

    bindInput(cutEl,   ()=>{ if(ctx){ ensureSynths(); applyBassParams(false); } scheduleSave(); });
    bindInput(resEl,   ()=>{ if(ctx){ ensureSynths(); applyBassParams(false); } scheduleSave(); });
    bindInput(envEl,   ()=>{ scheduleSave(); });
    bindInput(bDecayEl,()=>{ scheduleSave(); });
    bindInput(dMixEl,  ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });
    bindInput(dFbEl,   ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });

    bindInput(lCutEl,  ()=>{ if(ctx){ ensureSynths(); applyLeadParams(false); } scheduleSave(); });
    bindInput(lResEl,  ()=>{ if(ctx){ ensureSynths(); applyLeadParams(false); } scheduleSave(); });
    bindInput(lEnvEl,  ()=>{ scheduleSave(); });
    bindInput(lGateEl, ()=>{ scheduleSave(); });
    bindInput(lMixEl,  ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });
    bindInput(lFbEl,   ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });

    bassResetBtn.addEventListener("click", () => {
      bassState = makeSeqState();
      renderSeqGrid(tbGridEl, bassState, "bass");
      scheduleSave();
    });
    leadResetBtn.addEventListener("click", () => {
      leadState = makeSeqState();
      renderSeqGrid(leadGridEl, leadState, "lead");
      scheduleSave();
    });

    // ---------- transport / scheduler ----------
    let isRunning = false;
    let playStep = 0;
    let drumStep = 0;
    let bassStep = 0;
    let leadStep = 0;
    let nextTime = 0;
    let timer = null;
    let rafId = null;
    let startTime = 0;

    const AHEAD_SEC = 0.04;
    const LOOKAHEAD_MS = 15;

    function hzForNote(noteName, oct){
      const baseMidi = 45; // A2
      const semi = NOTE_TO_SEMI[noteName];
      if(semi === undefined) return NaN;
      const o = isFinite(oct) ? oct : 0;
      const midi = baseMidi + semi + (o * 12);
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    // BASS plays every 16th note step
    function scheduleBass(step16, t){
      ensureSynths();

      const b = bassState.steps[bassStep];
      if(b.note){
        const freq = hzForNote(b.note, b.oct);
        const decay = clamp(+bDecayEl.value || 0.28, 0.08, 0.60);
        const envAmt = clamp(+envEl.value || 0, 0, 1);
        const baseCut = clamp(+cutEl.value || 0, 0, 1);
        bassSynth.trigger({ freq, time:t, decay, gate:0.55, envAmt, baseCut01: baseCut, release:0.10, vel:1.0 });
      }
      bassStep = (bassStep + 1) % 16;
      applyBassParams(false);
    }

    // LEAD plays every 16th note step
    function scheduleLead(step16, t){
      ensureSynths();

      const l = leadState.steps[leadStep];
      if(l.note){
        const freq = hzForNote(l.note, l.oct+1);
        const envAmt = clamp(+lEnvEl.value || 0, 0, 1);
        const baseCut = clamp(+lCutEl.value || 0, 0, 1);
        const gate = clamp(+lGateEl.value || 0.55, 0.10, 1.0);
        leadSynth.trigger({ freq, time:t, decay:0.22, gate, envAmt, baseCut01: baseCut, release:0.11, vel:1.0 });
      }
      leadStep = (leadStep + 1) % 16;
      applyLeadParams(false);
    }

    var pendingRecordingUI = null;
    
    function scheduleStep(stepIndex, time){
      // 16 steps = 1 bar of 16th notes
      // At step 0, we're starting a new bar
      
      if(stepIndex === 0){
        // Increment bar counter (1, 2, 3, 4, then back to 1)
        currentBar++;
        if(currentBar > 4) currentBar = 1;
        
        // ---- RECORDING LOGIC ----
        if(recordingSlot >= 0){
          // Recording in progress - check if we've done 4 bars
          if(recordingBarCount >= 4){
            // Finished 4 bars, stop recording
            stopLoopRecording();
          } else {
            // Still recording, increment bar count
            recordingBarCount++;
            // Defer UI update
            pendingRecordingUI = recordingBarCount;
          }
        } else if(armedSlot >= 0){
          // Start recording at bar 1
          currentBar = 1;
          startLoopRecording(armedSlot);
        }
      }

      for(const tr of tracks){
        if(tr.pattern[stepIndex]){
          if(tr.key === "kick") triggerSidechain(time);

          const g = ensureTrackGain(tr.key);
          setTrackGain(tr.key, tr.vol, true);

          if(tr.isSampler){
            if(tr.key==="sample1") playSampleNow(1, time);
            else if(tr.key==="sample2") playSampleNow(2, time);
          }else if(tr.buffer){
            playBufferAt(tr.buffer, time, g);
          }
        }
      }

      // bass stays as before
      scheduleBass(stepIndex, time);
      // lead runs 2× tempo
      scheduleLead(stepIndex, time);
    }

    function scheduler(){
      if(!isRunning) return;
      const stepDur = sixteenthSec();

      while(nextTime < ctx.currentTime + AHEAD_SEC){
        scheduleStep(drumStep, nextTime);
        drumStep = (drumStep + 1) % 16;
        nextTime += stepDur;
      }
      
      // Deferred UI update for recording
      if(pendingRecordingUI !== null){
        updateLoopUI();
        setStatus("Recording Loop " + (recordingSlot + 1) + "... (Bar " + pendingRecordingUI + "/4)");
        pendingRecordingUI = null;
      }
      
      timer = setTimeout(scheduler, LOOKAHEAD_MS);
    }

    function updatePlayhead(){
      if(!isRunning) return;
      const stepDur = sixteenthSec();
      const elapsed = ctx.currentTime - startTime;
      const idx = ((elapsed/stepDur)%16 + 16) % 16;
      const newStep = Math.floor(idx);
      if(newStep !== playStep){
        playStep = newStep;
        setPlayheadUI(playStep);
      }
      rafId = requestAnimationFrame(updatePlayhead);
    }

    async function masterPlay(){
      await resumeAudio();
      ensureSynths();
      applyBassParams(true);
      applyLeadParams(true);
      applyMixerNow(true);

      for(const tr of tracks){
        ensureTrackGain(tr.key);
        setTrackGain(tr.key, tr.vol, true);
      }

      const ok = tracks.some(tr => (tr.isSampler ? !!tr.buffer : !!tr.buffer));
      if(!ok){
        setStatus("No sounds (load ./samples or record Sample).");
        return;
      }

      isRunning = true;
      playStep = 0;
      drumStep = 0;
      bassStep = 0;
      leadStep = 0;
      currentBar = 0; // Will become 1 at first step 0
      loopBarsPlayed = 0; // Reset - loop will start fresh at step 0
      
      // Stop independent loop bar timer - sequencer will handle it now
      stopLoopBarTimer();
      
      // Stop any independently playing loop
      if(playingSlot >= 0){
        stopLoopPlayback();
      }

      startTime = ctx.currentTime + 0.06;
      nextTime = startTime;

      if(timer) clearTimeout(timer);
      if(rafId) cancelAnimationFrame(rafId);

      masterPlayBtn.disabled = true;
      masterStopBtn.disabled = false;

      setPlayheadUI(0);
      rafId = requestAnimationFrame(updatePlayhead);
      scheduler();

      setStatus("Playing");
    }

    function masterStop(){
      isRunning = false;
      hubPlaying = false; // Stop hub playback too
      if(timer) clearTimeout(timer);
      timer = null;
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;

      // Stop any ongoing loop recording
      if(recordingSlot >= 0) stopLoopRecording();
      
      // Stop loop scheduler
      stopLoopScheduler();
      
      // Hide student name overlay
      hideStudentName();
      
      armedSlot = -1;
      pendingPlaySlot = -1;
      playingSlot = -1;
      loopBarsPlayed = 0;
      loopStep = 0;
      currentBar = 0;
      updateLoopUI();

      hardStopAllSources();
      clearPlayheadUI();

      masterPlayBtn.disabled = false;
      masterStopBtn.disabled = true;

      setStatus("Stopped");
    }

    masterPlayBtn.addEventListener("click", masterPlay);
    masterStopBtn.addEventListener("click", masterStop);

    // ---------- save / load ----------
    const saveFileBtn = document.getElementById("saveFileBtn");
    const loadFileBtn = document.getElementById("loadFileBtn");
    const loadFileInput = document.getElementById("loadFileInput");

    const STORE_KEY = "mm_drum_bass_lead_mixer_Anatural_v3_16step";

    let saveTimer=null;
    let dirty=false;
    function scheduleSave(){
      dirty = true;
      clearTimeout(saveTimer);
      saveTimer = setTimeout(saveNow, 220);
    }
    function saveNow(){
      try{
        localStorage.setItem(STORE_KEY, JSON.stringify(gatherState()));
        dirty = false;
      }catch(_){}
    }
    function loadSaved(){
      const raw = localStorage.getItem(STORE_KEY);
      return raw ? safeJSONParse(raw) : null;
    }
    window.addEventListener("beforeunload", ()=>{ if(dirty) saveNow(); });
    setInterval(()=>{ if(dirty) saveNow(); }, 2500);

    function gatherState(){
      return {
        tempo: tempo(),
        masterVol: +masterVolEl.value,
        sidechain: sideAmt(),
        drum: tracks.map(t=>({ key:t.key, pattern:[...t.pattern], vol:+t.vol })),
        bassState,
        leadState,
        params:{
          bass:{ cut:+cutEl.value, res:+resEl.value, env:+envEl.value, dec:+bDecayEl.value, mix:+dMixEl.value, fb:+dFbEl.value },
          lead:{ cut:+lCutEl.value, res:+lResEl.value, env:+lEnvEl.value, gate:+lGateEl.value, mix:+lMixEl.value, fb:+lFbEl.value },
          mixer:{
            dV:+mDrumVolEl.value, bV:+mBassVolEl.value, lV:+mLeadVolEl.value,
            dF:+mDrumLPFEl.value, bF:+mBassLPFEl.value, lF:+mLeadLPFEl.value,
            dm:mute.drums, bm:mute.bass, lm:mute.lead
          },
          samp:{
            s1Mix:+s1MixEl.value, s1Fb:+s1FbEl.value, s1Pitch:+s1PitchEl.value,
            s2Mix:+s2MixEl.value, s2Fb:+s2FbEl.value, s2Pitch:+s2PitchEl.value
          }
        }
      };
    }

    function applyState(st){
      if(!st) return;

      if(st.tempo) tempoEl.value = String(clamp(st.tempo,80,160));
      tempoVal.textContent = String(tempo());

      if(typeof st.masterVol === "number") masterVolEl.value = String(clamp(st.masterVol,0,1));
      if(typeof st.sidechain === "number"){
        sidechainAmtEl.value = String(clamp(st.sidechain,0,1));
        sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);
      }

      if(Array.isArray(st.drum)){
        for(const savedTr of st.drum){
          const tr = tracksByKey.get(savedTr.key);
          if(tr && Array.isArray(savedTr.pattern) && savedTr.pattern.length===16){
            tr.pattern = savedTr.pattern.map(Boolean);
            for(let s=0;s<16;s++) toggleCellUI(tr.key, s, tr.pattern[s]);
          }
          if(tr && typeof savedTr.vol === "number"){
            tr.vol = clamp(savedTr.vol, 0, 1);
            if(tr._ui?.volEl) tr._ui.volEl.value = String(tr.vol);
            if(ctx){ ensureTrackGain(tr.key); setTrackGain(tr.key, tr.vol, true); }
          }
        }
      }

      if(st.bassState){
        bassState = st.bassState;
        // Ensure 16 steps (upgrade from old 8-step saves)
        while(bassState.steps.length < 16) bassState.steps.push({ note:null, oct:0 });
      }
      if(st.leadState){
        leadState = st.leadState;
        // Ensure 16 steps (upgrade from old 8-step saves)
        while(leadState.steps.length < 16) leadState.steps.push({ note:null, oct:0 });
      }

      if(st.params?.bass){
        cutEl.value = String(clamp(st.params.bass.cut ?? +cutEl.value,0,1));
        resEl.value = String(clamp(st.params.bass.res ?? +resEl.value,0,1));
        envEl.value = String(clamp(st.params.bass.env ?? +envEl.value,0,1));
        bDecayEl.value = String(clamp(st.params.bass.dec ?? +bDecayEl.value,0.08,0.60));
        dMixEl.value = String(clamp(st.params.bass.mix ?? +dMixEl.value,0,1));
        dFbEl.value  = String(clamp(st.params.bass.fb  ?? +dFbEl.value,0,0.75));
      }

      if(st.params?.lead){
        lCutEl.value = String(clamp(st.params.lead.cut ?? +lCutEl.value,0,1));
        lResEl.value = String(clamp(st.params.lead.res ?? +lResEl.value,0,1));
        lEnvEl.value = String(clamp(st.params.lead.env ?? +lEnvEl.value,0,1));
        lGateEl.value= String(clamp(st.params.lead.gate?? +lGateEl.value,0.10,1));
        lMixEl.value = String(clamp(st.params.lead.mix ?? +lMixEl.value,0,1));
        lFbEl.value  = String(clamp(st.params.lead.fb  ?? +lFbEl.value,0,0.75));
      }

      if(st.params?.mixer){
        mDrumVolEl.value = String(clamp(st.params.mixer.dV ?? +mDrumVolEl.value,0,1));
        mBassVolEl.value = String(clamp(st.params.mixer.bV ?? +mBassVolEl.value,0,1));
        mLeadVolEl.value = String(clamp(st.params.mixer.lV ?? +mLeadVolEl.value,0,1));
        mDrumLPFEl.value = String(clamp(st.params.mixer.dF ?? +mDrumLPFEl.value,0,1));
        mBassLPFEl.value = String(clamp(st.params.mixer.bF ?? +mBassLPFEl.value,0,1));
        mLeadLPFEl.value = String(clamp(st.params.mixer.lF ?? +mLeadLPFEl.value,0,1));

        mute.drums = !!st.params.mixer.dm;
        mute.bass  = !!st.params.mixer.bm;
        mute.lead  = !!st.params.mixer.lm;

        mDrumMuteBtn.classList.toggle("on", mute.drums);
        mBassMuteBtn.classList.toggle("on", mute.bass);
        mLeadMuteBtn.classList.toggle("on", mute.lead);
        mDrumMuteBtn.textContent = mute.drums ? "Muted" : "Mute";
        mBassMuteBtn.textContent = mute.bass ? "Muted" : "Mute";
        mLeadMuteBtn.textContent = mute.lead ? "Muted" : "Mute";
      }

      if(st.params?.samp){
        s1MixEl.value = String(clamp(st.params.samp.s1Mix ?? +s1MixEl.value,0,1));
        s1FbEl.value  = String(clamp(st.params.samp.s1Fb  ?? +s1FbEl.value,0,0.75));
        s1PitchEl.value = String(clamp(st.params.samp.s1Pitch ?? +s1PitchEl.value,-12,12));
        s2MixEl.value = String(clamp(st.params.samp.s2Mix ?? +s2MixEl.value,0,1));
        s2FbEl.value  = String(clamp(st.params.samp.s2Fb  ?? +s2FbEl.value,0,0.75));
        s2PitchEl.value = String(clamp(st.params.samp.s2Pitch ?? +s2PitchEl.value,-12,12));
        s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
        s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);
      }

      renderSeqGrid(tbGridEl, bassState, "bass");
      renderSeqGrid(leadGridEl, leadState, "lead");
      updateTrackLabels();

      if(ctx){
        applyMixerNow(true);
        ensureSynths();
        applyBassParams(true);
        applyLeadParams(true);
      }
    }

    saveFileBtn.addEventListener("click", () => {
      const data = JSON.stringify(gatherState(), null, 2);
      const blob = new Blob([data], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pattern.mmjson";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 500);
    });

    loadFileBtn.addEventListener("click", ()=>loadFileInput.click());
    loadFileInput.addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      if(!f) return;
      try{
        const text = await f.text();
        const st = safeJSONParse(text);
        if(st) applyState(st);
        scheduleSave();
        setStatus("Loaded ");
      }catch(err){
        console.error(err);
        setStatus("Load failed");
      }finally{
        loadFileInput.value = "";
      }
    });

    // ---------- init ----------
    hookMixer();
    buildHeader();
    buildGridOnce();
    renderSeqGrid(tbGridEl, bassState, "bass");
    renderSeqGrid(leadGridEl, leadState, "lead");
    updateLoopUI();

    loadAllSounds();

    const saved = loadSaved();
    if(saved){
      applyState(saved);
      setStatus("Autosave loaded ");
    }else{
      setStatus("Ready - Click a loop button to arm, then Play to record 4 bars!");
    }
  })();
  </script>
</body>
</html>
