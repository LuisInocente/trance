<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>Music Maker v2</title>
  <style>
    :root{
      --bg:#0a0a0f;
      --card:#16161e;
      --border:#2a2a3a;
      --text:#e8e8f0;
      --muted:#6a6a80;
      --accent:#6366f1;
      --gridBorder:#1e1e28;
      --noteGrey:#2a2a3a;
      --kick:#f97316;
      --snare:#fbbf24;
      --hihat:#22c55e;
      --clap:#ec4899;
      --bass:#3b82f6;
      --lead:#f97316;
      --pad:#a855f7;
      --piano:#22c55e;
    }
    *{ box-sizing:border-box; margin:0; padding:0; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; overflow:hidden; }
    body{
      font-family: system-ui, -apple-system, sans-serif;
      background:var(--bg);
      color:var(--text);
      display:flex;
      flex-direction:column;
    }
    
    header{
      position:sticky; top:0; z-index:50;
      background:var(--card);
      border-bottom:1px solid var(--border);
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    
    .headerLeft, .headerMid, .headerRight{ display:flex; align-items:center; gap:8px; }
    
    .pill{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      background:var(--bg);
      border-radius:8px;
      border:1px solid var(--border);
      font-size:12px;
      font-weight:600;
    }
    .pill input[type="range"]{ width:80px; }
    
    button{
      border:1px solid var(--border);
      border-radius:8px;
      background:var(--card);
      color:var(--text);
      cursor:pointer;
      font-weight:600;
      transition: all 0.1s;
    }
    button:hover{ background:var(--border); }
    button:disabled{ opacity:0.5; cursor:not-allowed; }
    
    .primary{
      background:var(--accent);
      border-color:var(--accent);
      color:#fff;
      padding:10px 20px;
      font-size:14px;
    }
    .primary:hover{ background:#5558e8; }
    
    .smallBtn{
      padding:6px 12px;
      font-size:11px;
    }
    
    .loopSlots{ display:flex; gap:6px; }
    .loopSlot{ display:flex; flex-direction:column; align-items:center; gap:2px; }
    .loopBtn{
      width:44px; height:36px;
      border:2px solid var(--border);
      border-radius:10px;
      background:var(--card);
      font-weight:900;
      font-size:14px;
    }
    .loopBtn.armed{ background:#f59e0b33; border-color:#f59e0b; animation:pulse 0.8s infinite; }
    .loopBtn.recording{ background:#ef444466; border-color:#ef4444; animation:pulse 0.5s infinite; }
    .loopBtn.ready{ background:#22c55e33; border-color:#22c55e; }
    .loopBtn.playing{ background:#3b82f666; border-color:#3b82f6; box-shadow:0 0 15px rgba(59,130,246,0.4); }
    @keyframes pulse{ 0%,100%{ opacity:1; } 50%{ opacity:0.7; } }
    .loopStatus{ font-size:9px; color:var(--muted); }
    
    .loopControlBtn{
      padding:8px 12px;
      font-size:11px;
      font-weight:700;
    }
    .loopControlBtn.stop{ background:#dc262633; border-color:#dc2626; }
    
    main{
      flex:1;
      overflow-y:auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
    }
    .cardHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 14px;
      border-bottom:1px solid var(--border);
    }
    .cardTitle{ font-weight:800; font-size:14px; }
    .cardBody{ padding:10px; }
    
    /* Drum Grid */
    .drumGrid{
      display:grid;
      grid-template-columns: 100px repeat(16, 1fr);
      gap:1px;
    }
    .drumRow{ display:contents; }
    .drumLabel{
      display:flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      font-size:10px;
      font-weight:700;
      background:var(--card);
    }
    .drumSwatch{
      width:8px; height:8px;
      border-radius:50%;
    }
    .drumCell{
      height:28px;
      background:#4a4a5a;
      border-radius:4px;
      cursor:pointer;
      transition: all 0.1s;
    }
    .drumCell.beatB{ background:#3a3a4a; }
    .drumCell:hover{ filter:brightness(1.2); }
    .drumCell.on{ background:var(--kick); }
    .drumCell.playhead{ box-shadow: inset 0 0 0 2px #fff; }
    .drumRow[data-color="snare"] .drumCell.on{ background:var(--snare); }
    .drumRow[data-color="hihat"] .drumCell.on{ background:var(--hihat); }
    .drumRow[data-color="clap"] .drumCell.on{ background:var(--clap); }
    
    .drumMuteBtn{
      width:20px; height:20px;
      border-radius:4px;
      font-size:9px;
      padding:0;
      margin-left:auto;
    }
    .drumMuteBtn.muted{ background:#dc2626; border-color:#dc2626; color:#fff; }
    
    /* Melody Section */
    .melodyControls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .soundSelect{
      padding:8px 12px;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:8px;
      color:var(--text);
      font-size:12px;
      font-weight:600;
      cursor:pointer;
    }
    .barNav{ display:flex; gap:4px; }
    .barNavBtn{
      padding:6px 12px;
      font-size:11px;
      font-weight:700;
    }
    .barNavBtn.active{ background:var(--accent); border-color:var(--accent); color:#fff; }
    
    .createBtn{
      padding:8px 16px;
      background:#22c55e;
      border-color:#22c55e;
      color:#fff;
      font-weight:700;
    }
    .createBtn:hover{ background:#16a34a; }
    
    .clearGridBtn{
      padding:8px 12px;
      font-size:11px;
    }
    
    /* Melody Grid */
    .melodyGrid{
      display:grid;
      grid-template-columns: 40px repeat(32, 1fr);
      gap:1px;
      margin-top:10px;
    }
    .melodyRow{ display:contents; }
    .melodyLabel{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      font-weight:800;
      background:var(--card);
      color:#fff;
    }
    .melodyCell{
      height:32px;
      background:#4a4a5a;
      border-radius:4px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:9px;
      font-weight:700;
      color:transparent;
      transition: all 0.1s;
    }
    .melodyCell.beatB{ background:#3a3a4a; }
    .melodyCell:hover{ filter:brightness(1.2); }
    .melodyCell.on{ color:#fff; }
    .melodyCell.bass{ background:var(--bass); }
    .melodyCell.lead{ background:var(--lead); }
    .melodyCell.pad{ background:var(--pad); }
    .melodyCell.piano{ background:var(--piano); }
    .melodyCell.playhead{ box-shadow: inset 0 0 0 2px #fff; }
    
    .melodyCell.bar2{ opacity:0.85; }
    
    /* Step numbers */
    .stepNumbers{
      display:grid;
      grid-template-columns: 40px repeat(32, 1fr);
      gap:1px;
      margin-bottom:2px;
    }
    .stepNum{
      font-size:8px;
      color:#fff;
      text-align:center;
      font-weight:700;
    }
    
    /* Lanes */
    .lanesSection{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .lane{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:10px;
      cursor:pointer;
      transition: all 0.15s;
    }
    .lane:hover{ border-color:var(--accent); }
    .lane.active{ border-color:var(--accent); background:#6366f122; }
    .lane.empty{ opacity:0.5; }
    .laneSwatch{
      width:16px; height:16px;
      border-radius:50%;
      flex:0 0 auto;
    }
    .laneName{
      font-weight:700;
      font-size:13px;
      min-width:50px;
    }
    .laneVol{
      flex:1;
      max-width:200px;
    }
    .laneMute{
      width:28px; height:28px;
      font-size:11px;
      font-weight:700;
      padding:0;
    }
    .laneMute.muted{ background:#dc2626; border-color:#dc2626; color:#fff; }
    
    /* Drum mixer in header */
    .drumMixer{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      background:var(--bg);
      border-radius:8px;
      border:1px solid var(--border);
    }
    .drumMixer span{
      font-size:11px;
      font-weight:700;
    }
    .drumMixer input[type="range"]{ width:60px; }
    .drumMixerMute{
      width:24px; height:24px;
      font-size:10px;
      padding:0;
    }
    .drumMixerMute.active{ background:#dc2626; border-color:#dc2626; color:#fff; }
    
    footer{
      padding:8px 12px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:11px;
      color:var(--muted);
    }
    
    /* Hub Modal */
    .modal{
      display:none;
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.9);
      z-index:100;
      align-items:center;
      justify-content:center;
    }
    .modal.open{ display:flex; }
    .modalContent{
      background:var(--card);
      border-radius:16px;
      padding:20px;
      max-width:500px;
      width:95%;
      max-height:90vh;
      overflow-y:auto;
    }
    
    @media(max-width:768px){
      .drumGrid{ grid-template-columns: 80px repeat(16, 1fr); }
      .melodyGrid{ grid-template-columns: 30px repeat(32, 1fr); }
      .stepNumbers{ grid-template-columns: 30px repeat(32, 1fr); }
    }
  </style>
</head>
<body>
  <header>
    <div class="headerLeft">
      <div class="pill">
        <span>Tempo</span>
        <input type="range" id="tempo" min="80" max="160" value="120">
        <strong id="tempoVal">120</strong>
      </div>
      <div class="pill">
        <span>Vol</span>
        <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
      </div>
      <div class="drumMixer">
        <span>Drums</span>
        <input type="range" id="drumVol" min="0" max="1" step="0.01" value="0.8">
        <button id="drumMute" class="drumMixerMute">M</button>
      </div>
    </div>
    
    <div class="headerMid">
      <button id="playBtn" class="primary">‚ñ∂ Play</button>
      <button id="stopBtn" disabled>‚ñ† Stop</button>
    </div>
    
    <div class="headerRight">
      <div class="loopSlots">
        <div class="loopSlot">
          <button class="loopBtn" data-slot="0">1</button>
          <span class="loopStatus">Empty</span>
        </div>
        <div class="loopSlot">
          <button class="loopBtn" data-slot="1">2</button>
          <span class="loopStatus">Empty</span>
        </div>
        <div class="loopSlot">
          <button class="loopBtn" data-slot="2">3</button>
          <span class="loopStatus">Empty</span>
        </div>
        <div class="loopSlot">
          <button class="loopBtn" data-slot="3">4</button>
          <span class="loopStatus">Empty</span>
        </div>
      </div>
      <button class="loopControlBtn stop" id="loopStopBtn">Stop</button>
      <button class="loopControlBtn" id="hubBtn">Hub</button>
    </div>
  </header>
  
  <main>
    <!-- Drum Machine -->
    <div class="card">
      <div class="cardHead">
        <span class="cardTitle">Drums</span>
        <div style="display:flex;gap:6px;">
          <button class="smallBtn" id="saveBtn">Save</button>
          <button class="smallBtn" id="loadBtn">Load</button>
          <button class="smallBtn" id="clearDrumBtn">Clear</button>
        </div>
      </div>
      <div class="cardBody">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>
    
    <!-- Melody Editor -->
    <div class="card">
      <div class="cardHead">
        <span class="cardTitle">Melody</span>
        <div class="melodyControls">
          <select class="soundSelect" id="soundSelect">
            <option value="bass">Bass</option>
            <option value="lead">Lead</option>
            <option value="pad">Pad</option>
            <option value="piano">Piano</option>
          </select>
          <div class="barNav">
            <button class="barNavBtn active" data-bars="0">Bars 1-2</button>
            <button class="barNavBtn" data-bars="1">Bars 3-4</button>
          </div>
          <button class="clearGridBtn smallBtn" id="clearMelodyBtn">Clear</button>
          <button class="createBtn" id="createBtn">Create ‚Üí</button>
        </div>
      </div>
      <div class="cardBody">
        <div class="stepNumbers" id="stepNumbers"></div>
        <div class="melodyGrid" id="melodyGrid"></div>
      </div>
    </div>
    
    <!-- Lanes -->
    <div class="card">
      <div class="cardHead">
        <span class="cardTitle">Tracks</span>
      </div>
      <div class="cardBody lanesSection" id="lanes">
        <div class="lane empty" data-sound="bass">
          <div class="laneSwatch" style="background:var(--bass)"></div>
          <span class="laneName">Bass</span>
          <input type="range" class="laneVol" min="0" max="1" step="0.01" value="0.8">
          <button class="laneMute">M</button>
        </div>
        <div class="lane empty" data-sound="lead">
          <div class="laneSwatch" style="background:var(--lead)"></div>
          <span class="laneName">Lead</span>
          <input type="range" class="laneVol" min="0" max="1" step="0.01" value="0.8">
          <button class="laneMute">M</button>
        </div>
        <div class="lane empty" data-sound="pad">
          <div class="laneSwatch" style="background:var(--pad)"></div>
          <span class="laneName">Pad</span>
          <input type="range" class="laneVol" min="0" max="1" step="0.01" value="0.8">
          <button class="laneMute">M</button>
        </div>
        <div class="lane empty" data-sound="piano">
          <div class="laneSwatch" style="background:var(--piano)"></div>
          <span class="laneName">Piano</span>
          <input type="range" class="laneVol" min="0" max="1" step="0.01" value="0.8">
          <button class="laneMute">M</button>
        </div>
      </div>
    </div>
  </main>
  
  <footer>
    <button class="smallBtn" id="printBtn">üñ®Ô∏è Print</button>
    <span>Music Maker v2 - 2026</span>
  </footer>
  
  <input type="file" id="loadFileInput" accept=".json" style="display:none">
  
  <!-- Hub Modal -->
  <div class="modal" id="hubModal">
    <div class="modalContent">
      <h2 style="margin-bottom:16px;">Classroom Hub</h2>
      <div style="margin-bottom:12px;">
        <input type="text" id="hubUrl" placeholder="Server URL" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--border);background:var(--bg);color:var(--text);">
      </div>
      <div style="display:flex;gap:8px;margin-bottom:16px;">
        <button class="smallBtn" id="hubRefresh">Refresh</button>
        <button class="smallBtn" id="hubSubmit">Submit All</button>
      </div>
      <div id="hubProjects" style="max-height:300px;overflow-y:auto;"></div>
      <button class="smallBtn" id="hubClose" style="margin-top:16px;width:100%;">Close</button>
    </div>
  </div>

<script>
(function(){
  "use strict";
  
  // ===== AUDIO CONTEXT =====
  let ctx = null;
  let master = null;
  
  async function initAudio(){
    if(ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);
    await ctx.resume();
  }
  
  // ===== UTILITIES =====
  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
  
  function bindInput(el, fn){
    if(!el) return;
    el.addEventListener("input", fn);
    el.addEventListener("change", fn);
  }
  
  // ===== TEMPO =====
  const tempoEl = document.getElementById("tempo");
  const tempoValEl = document.getElementById("tempoVal");
  const masterVolEl = document.getElementById("masterVol");
  
  function tempo(){ return clamp(+tempoEl.value || 120, 80, 160); }
  function stepDuration(){ return 60 / tempo() / 4; }
  
  bindInput(tempoEl, () => {
    tempoValEl.textContent = tempo();
  });
  
  bindInput(masterVolEl, () => {
    if(master) master.gain.value = clamp(+masterVolEl.value, 0, 1);
  });
  
  // ===== DRUM MACHINE =====
  const drumTracks = [
    { key: "kick", name: "Kick", color: "kick", pattern: new Array(16).fill(false), muted: false, buffer: null },
    { key: "snare", name: "Snare", color: "snare", pattern: new Array(16).fill(false), muted: false, buffer: null },
    { key: "hihat", name: "Hi-Hat", color: "hihat", pattern: new Array(16).fill(false), muted: false, buffer: null },
    { key: "clap", name: "Clap", color: "clap", pattern: new Array(16).fill(false), muted: false, buffer: null }
  ];
  
  const drumGridEl = document.getElementById("drumGrid");
  const drumCells = new Map();
  
  const drumVolEl = document.getElementById("drumVol");
  const drumMuteEl = document.getElementById("drumMute");
  let drumGain = null;
  let drumMuted = false;
  
  function buildDrumGrid(){
    drumGridEl.innerHTML = "";
    
    drumTracks.forEach((track, ti) => {
      const row = document.createElement("div");
      row.className = "drumRow";
      row.dataset.color = track.color;
      
      // Label
      const label = document.createElement("div");
      label.className = "drumLabel";
      
      const swatch = document.createElement("div");
      swatch.className = "drumSwatch";
      swatch.style.background = `var(--${track.color})`;
      label.appendChild(swatch);
      
      const name = document.createElement("span");
      name.textContent = track.name;
      label.appendChild(name);
      
      // Mute button
      const muteBtn = document.createElement("button");
      muteBtn.className = "drumMuteBtn" + (track.muted ? " muted" : "");
      muteBtn.textContent = "M";
      muteBtn.onclick = (e) => {
        e.stopPropagation();
        track.muted = !track.muted;
        muteBtn.classList.toggle("muted", track.muted);
      };
      label.appendChild(muteBtn);
      
      row.appendChild(label);
      
      // Cells
      const cells = [];
      for(let s = 0; s < 16; s++){
        const cell = document.createElement("div");
        const beatClass = (Math.floor(s / 4) % 2 === 1) ? " beatB" : "";
        cell.className = "drumCell" + beatClass + (track.pattern[s] ? " on" : "");
        cell.onclick = async () => {
          await initAudio();
          track.pattern[s] = !track.pattern[s];
          cell.classList.toggle("on", track.pattern[s]);
          if(track.pattern[s] && track.buffer && !track.muted){
            playBuffer(track.buffer, ctx.currentTime);
          }
        };
        cells.push(cell);
        row.appendChild(cell);
      }
      drumCells.set(track.key, cells);
      
      drumGridEl.appendChild(row);
    });
  }
  
  // Drum mixer
  bindInput(drumVolEl, () => {
    if(drumGain) drumGain.gain.value = drumMuted ? 0 : clamp(+drumVolEl.value, 0, 1);
  });
  
  drumMuteEl.onclick = () => {
    drumMuted = !drumMuted;
    drumMuteEl.classList.toggle("active", drumMuted);
    if(drumGain) drumGain.gain.value = drumMuted ? 0 : clamp(+drumVolEl.value, 0, 1);
  };
  
  function playBuffer(buffer, time, gain){
    if(!ctx || !buffer) return;
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    const g = gain || drumGain || master;
    src.connect(g);
    src.start(time);
  }
  
  // ===== LOAD DRUM SOUNDS FROM SERVER =====
  async function fetchArrayBuffer(url){
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) throw new Error("HTTP " + r.status);
    return await r.arrayBuffer();
  }
  
  async function loadOneTrack(track){
    track.buffer = null;
    for(const ext of ["wav","mp3","ogg"]){
      const url = "./samples/" + track.key + "." + ext;
      try{
        const arr = await fetchArrayBuffer(url);
        const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
        track.buffer = buf;
        return true;
      }catch(_){}
    }
    return false;
  }
  
  async function loadDrumSounds(){
    await initAudio();
    
    drumGain = ctx.createGain();
    drumGain.gain.value = clamp(+drumVolEl.value, 0, 1);
    drumGain.connect(master);
    
    let loaded = 0;
    for(const track of drumTracks){
      if(await loadOneTrack(track)) loaded++;
    }
    console.log(`Loaded ${loaded}/${drumTracks.length} drum sounds`);
  }
  
  // ===== MELODY GRID =====
  const notes = ["B", "A", "G", "F", "E", "D", "C"]; // Top to bottom
  const noteFreqs = { C: 261.63, D: 293.66, E: 329.63, F: 349.23, G: 392.00, A: 440.00, B: 493.88 };
  
  const melodyGridEl = document.getElementById("melodyGrid");
  const stepNumbersEl = document.getElementById("stepNumbers");
  const soundSelectEl = document.getElementById("soundSelect");
  const barNavBtns = document.querySelectorAll(".barNavBtn");
  const createBtn = document.getElementById("createBtn");
  const clearMelodyBtn = document.getElementById("clearMelodyBtn");
  
  // Grid state: 64 steps x 7 notes, each cell has octave (-1, 0, 1) or null
  let melodyGridState = [];
  for(let n = 0; n < 7; n++){
    melodyGridState.push(new Array(64).fill(null));
  }
  
  let currentBarView = 0; // 0 = bars 1-2, 1 = bars 3-4
  let melodyCells = [];
  
  function buildMelodyGrid(){
    // Step numbers
    stepNumbersEl.innerHTML = "<div></div>";
    const startStep = currentBarView * 32;
    for(let s = 0; s < 32; s++){
      const num = document.createElement("div");
      num.className = "stepNum";
      num.textContent = startStep + s + 1;
      stepNumbersEl.appendChild(num);
    }
    
    // Grid
    melodyGridEl.innerHTML = "";
    melodyCells = [];
    
    const sound = soundSelectEl.value;
    const isPolyphonic = (sound === "pad" || sound === "piano");
    
    notes.forEach((note, ni) => {
      const row = document.createElement("div");
      row.className = "melodyRow";
      
      const label = document.createElement("div");
      label.className = "melodyLabel";
      label.textContent = note;
      row.appendChild(label);
      
      const rowCells = [];
      for(let s = 0; s < 32; s++){
        const stepIdx = startStep + s;
        const cell = document.createElement("div");
        const beatClass = (Math.floor(s / 4) % 2 === 1) ? " beatB" : "";
        cell.className = "melodyCell" + beatClass;
        
        const octave = melodyGridState[ni][stepIdx];
        if(octave !== null){
          cell.classList.add("on", sound);
          // Show note name + octave (e.g., "C-1", "G0", "A+1")
          const octStr = octave > 0 ? "+" + octave : octave;
          cell.textContent = note + octStr;
        }
        
        cell.onclick = async () => {
          await initAudio();
          
          const currentOct = melodyGridState[ni][stepIdx];
          
          // For monophonic, clear other notes in this step first
          if(!isPolyphonic && currentOct === null){
            for(let n = 0; n < 7; n++){
              if(melodyGridState[n][stepIdx] !== null){
                melodyGridState[n][stepIdx] = null;
              }
            }
          }
          
          // Cycle: null -> -1 -> 0 -> +1 -> null
          let newOct;
          if(currentOct === null) newOct = -1;
          else if(currentOct === -1) newOct = 0;
          else if(currentOct === 0) newOct = 1;
          else newOct = null;
          
          melodyGridState[ni][stepIdx] = newOct;
          
          // Preview note
          if(newOct !== null){
            const freq = noteFreqs[note] * Math.pow(2, newOct);
            playPreviewNote(sound, freq, 0.2);
          }
          
          buildMelodyGrid();
        };
        
        rowCells.push(cell);
        row.appendChild(cell);
      }
      melodyCells.push(rowCells);
      
      melodyGridEl.appendChild(row);
    });
  }
  
  // Bar navigation
  barNavBtns.forEach(btn => {
    btn.onclick = () => {
      barNavBtns.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      currentBarView = parseInt(btn.dataset.bars);
      buildMelodyGrid();
    };
  });
  
  // Sound select change
  soundSelectEl.onchange = () => {
    buildMelodyGrid();
  };
  
  // Clear melody grid
  clearMelodyBtn.onclick = () => {
    for(let n = 0; n < 7; n++){
      melodyGridState[n].fill(null);
    }
    buildMelodyGrid();
  };
  
  // ===== LANES =====
  const lanes = {
    bass: { notes: null, muted: false },
    lead: { notes: null, muted: false },
    pad: { notes: null, muted: false },
    piano: { notes: null, muted: false }
  };
  
  const lanesEl = document.getElementById("lanes");
  
  function updateLaneUI(){
    lanesEl.querySelectorAll(".lane").forEach(laneEl => {
      const sound = laneEl.dataset.sound;
      const data = lanes[sound];
      const hasNotes = data.notes !== null;
      
      laneEl.classList.toggle("empty", !hasNotes);
      
      const muteBtn = laneEl.querySelector(".laneMute");
      muteBtn.classList.toggle("muted", data.muted);
    });
    
    // Update gain nodes based on mute state
    if(typeof updateSynthVolumes === "function") updateSynthVolumes();
  }
  
  // Lane click handlers
  lanesEl.querySelectorAll(".lane").forEach(laneEl => {
    const sound = laneEl.dataset.sound;
    
    // Click lane to edit (but not on controls)
    laneEl.onclick = (e) => {
      // Don't trigger if clicking on controls
      if(e.target.classList.contains("laneVol") || 
         e.target.classList.contains("laneMute")) return;
      
      if(lanes[sound].notes){
        // Load into grid
        melodyGridState = lanes[sound].notes.map(row => [...row]);
        soundSelectEl.value = sound;
        buildMelodyGrid();
        
        // Highlight active lane
        lanesEl.querySelectorAll(".lane").forEach(l => l.classList.remove("active"));
        laneEl.classList.add("active");
      }
    };
    
    // Mute button
    laneEl.querySelector(".laneMute").onclick = (e) => {
      e.stopPropagation();
      lanes[sound].muted = !lanes[sound].muted;
      updateLaneUI();
    };
    
    // Volume slider
    laneEl.querySelector(".laneVol").onclick = (e) => e.stopPropagation();
  });
  
  // Create button
  createBtn.onclick = () => {
    const sound = soundSelectEl.value;
    
    // Copy grid state to lane
    lanes[sound].notes = melodyGridState.map(row => [...row]);
    
    updateLaneUI();
    
    // Clear grid for next instrument
    for(let n = 0; n < 7; n++){
      melodyGridState[n].fill(null);
    }
    buildMelodyGrid();
  };
  
  // ===== SYNTH SOUNDS =====
  let bassGain, leadGain, padGain, pianoGain;
  
  function createSynthGains(){
    if(!ctx) return;
    if(!bassGain){
      bassGain = ctx.createGain(); bassGain.connect(master);
      leadGain = ctx.createGain(); leadGain.connect(master);
      padGain = ctx.createGain(); padGain.connect(master);
      pianoGain = ctx.createGain(); pianoGain.connect(master);
    }
    updateSynthVolumes();
  }
  
  function updateSynthVolumes(){
    const bassVol = lanesEl.querySelector('[data-sound="bass"] .laneVol');
    const leadVol = lanesEl.querySelector('[data-sound="lead"] .laneVol');
    const padVol = lanesEl.querySelector('[data-sound="pad"] .laneVol');
    const pianoVol = lanesEl.querySelector('[data-sound="piano"] .laneVol');
    
    if(bassGain) bassGain.gain.value = lanes.bass.muted ? 0 : (bassVol ? +bassVol.value : 0.8);
    if(leadGain) leadGain.gain.value = lanes.lead.muted ? 0 : (leadVol ? +leadVol.value : 0.8);
    if(padGain) padGain.gain.value = lanes.pad.muted ? 0 : (padVol ? +padVol.value : 0.8);
    if(pianoGain) pianoGain.gain.value = lanes.piano.muted ? 0 : (pianoVol ? +pianoVol.value : 0.8);
  }
  
  // Hook volume sliders
  lanesEl.querySelectorAll(".laneVol").forEach(slider => {
    slider.addEventListener("input", updateSynthVolumes);
  });
  
  function playPreviewNote(sound, freq, duration){
    if(!ctx) return;
    
    switch(sound){
      case "bass": playBass(freq, ctx.currentTime, duration); break;
      case "lead": playLead(freq, ctx.currentTime, duration); break;
      case "pad": playPad(freq, ctx.currentTime, 0.5); break; // Longer preview for pad
      case "piano": playPiano(freq, ctx.currentTime, duration); break;
    }
  }
  
  function playBass(freq, time, dur){
    // Octave lower
    const bassFreq = freq / 2;
    
    // Sawtooth oscillator
    const osc1 = ctx.createOscillator();
    osc1.type = "sawtooth";
    osc1.frequency.setValueAtTime(bassFreq, time);
    
    // Sub sine for warmth
    const osc2 = ctx.createOscillator();
    osc2.type = "sine";
    osc2.frequency.setValueAtTime(bassFreq, time);
    
    // Lowpass filter with envelope
    const filter = ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.Q.setValueAtTime(2, time);
    // Filter envelope: start high, decay to low
    filter.frequency.setValueAtTime(bassFreq * 8, time);
    filter.frequency.exponentialRampToValueAtTime(bassFreq * 2, time + 0.1);
    filter.frequency.setTargetAtTime(bassFreq * 1.5, time + 0.1, 0.2);
    
    // Amp envelope with attack to avoid click
    const ampEnv = ctx.createGain();
    ampEnv.gain.setValueAtTime(0, time);
    ampEnv.gain.linearRampToValueAtTime(0.6, time + 0.005); // Quick attack
    ampEnv.gain.setTargetAtTime(0.4, time + 0.05, 0.1); // Sustain
    ampEnv.gain.setTargetAtTime(0, time + dur * 0.7, 0.08); // Release
    
    // Mixer for oscillators
    const sawGain = ctx.createGain();
    sawGain.gain.setValueAtTime(0.5, time);
    const sinGain = ctx.createGain();
    sinGain.gain.setValueAtTime(0.5, time);
    
    // Routing
    osc1.connect(sawGain);
    osc2.connect(sinGain);
    sawGain.connect(filter);
    sinGain.connect(filter);
    filter.connect(ampEnv);
    ampEnv.connect(bassGain || master);
    
    osc1.start(time);
    osc2.start(time);
    osc1.stop(time + dur + 0.2);
    osc2.stop(time + dur + 0.2);
  }
  
  function playLead(freq, time, dur){
    const osc = ctx.createOscillator();
    const filter = ctx.createBiquadFilter();
    const gain = ctx.createGain();
    
    osc.type = "square";
    osc.frequency.setValueAtTime(freq, time);
    
    // Filter with envelope
    filter.type = "lowpass";
    filter.Q.setValueAtTime(3, time);
    filter.frequency.setValueAtTime(freq * 6, time);
    filter.frequency.exponentialRampToValueAtTime(freq * 2, time + 0.15);
    
    // Amp envelope with attack
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.3, time + 0.005);
    gain.gain.setTargetAtTime(0, time + dur * 0.7, 0.05);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(leadGain || master);
    osc.start(time);
    osc.stop(time + dur + 0.2);
  }
  
  // ===== PAD VOICE (Legato) =====
  let activePadOscs = [];
  let activePadGain = null;
  
  function findNextPadNoteDuration(notesGrid, currentStep, loopLen, stepDur){
    // Look ahead to find next step with any note
    for(let i = 1; i < loopLen; i++){
      const checkStep = (currentStep + i) % loopLen;
      for(let ni = 0; ni < 7; ni++){
        if(notesGrid[ni][checkStep] !== null){
          return i * stepDur;
        }
      }
    }
    return (loopLen - (currentStep % loopLen)) * stepDur;
  }
  
  function playPad(freq, time, dur){
    // Stop any existing pad oscillators immediately
    activePadOscs.forEach(osc => {
      try { osc.stop(time + 0.02); } catch(e){}
    });
    activePadOscs = [];
    
    // Lowpass filter for round sound
    const filter = ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(freq * 2, time);
    filter.Q.setValueAtTime(0.5, time);
    
    // Create gain envelope
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.4, time + 0.15);
    // Hold until release
    if(dur > 0.2){
      gain.gain.setValueAtTime(0.4, time + dur - 0.15);
      gain.gain.linearRampToValueAtTime(0, time + dur);
    } else {
      gain.gain.linearRampToValueAtTime(0, time + dur);
    }
    
    // 3 detuned saw waves filtered
    const detunes = [-7, 0, 7];
    for(let i = 0; i < 3; i++){
      const osc = ctx.createOscillator();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(freq, time);
      osc.detune.setValueAtTime(detunes[i], time);
      
      const oscGain = ctx.createGain();
      oscGain.gain.setValueAtTime(0.15, time);
      
      osc.connect(oscGain);
      oscGain.connect(filter);
      osc.start(time);
      osc.stop(time + dur + 0.2);
      activePadOscs.push(osc);
    }
    
    filter.connect(gain);
    gain.connect(padGain || master);
    activePadGain = gain;
  }
  
  function stopPad(){
    if(ctx && activePadOscs.length > 0){
      const now = ctx.currentTime;
      activePadOscs.forEach(osc => {
        try { osc.stop(now + 0.1); } catch(e){}
      });
      activePadOscs = [];
      if(activePadGain){
        activePadGain.gain.cancelScheduledValues(now);
        activePadGain.gain.setValueAtTime(activePadGain.gain.value, now);
        activePadGain.gain.linearRampToValueAtTime(0, now + 0.1);
      }
    }
  }
  
  function playPiano(freq, time, dur){
    // Piano-like sound with multiple harmonics - staccato
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc1.type = "triangle";
    osc1.frequency.setValueAtTime(freq, time);
    
    osc2.type = "sine";
    osc2.frequency.setValueAtTime(freq * 2, time); // Octave harmonic
    
    const osc1Gain = ctx.createGain();
    osc1Gain.gain.setValueAtTime(0.35, time);
    const osc2Gain = ctx.createGain();
    osc2Gain.gain.setValueAtTime(0.1, time);
    
    // Staccato envelope - quick attack, fast decay
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.5, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
    
    osc1.connect(osc1Gain);
    osc2.connect(osc2Gain);
    osc1Gain.connect(gain);
    osc2Gain.connect(gain);
    gain.connect(pianoGain || master);
    
    osc1.start(time);
    osc2.start(time);
    osc1.stop(time + 0.2);
    osc2.stop(time + 0.2);
  }
  
  // ===== PLAYBACK =====
  let isPlaying = false;
  let playScheduler = null;
  let currentStep = 0;
  let nextStepTime = 0;
  const scheduleAhead = 0.1;
  
  const playBtn = document.getElementById("playBtn");
  const stopBtn = document.getElementById("stopBtn");
  
  playBtn.onclick = async () => {
    await initAudio();
    await loadDrumSounds();
    createSynthGains();
    startPlayback();
  };
  
  stopBtn.onclick = () => {
    stopPlayback();
  };
  
  function startPlayback(){
    if(isPlaying) return;
    isPlaying = true;
    currentStep = 0;
    nextStepTime = ctx.currentTime + 0.05;
    
    playBtn.disabled = true;
    stopBtn.disabled = false;
    
    playScheduler = setInterval(scheduleNotes, 25);
  }
  
  function stopPlayback(){
    isPlaying = false;
    if(playScheduler){
      clearInterval(playScheduler);
      playScheduler = null;
    }
    
    // Stop any active pad
    stopPad();
    
    playBtn.disabled = false;
    stopBtn.disabled = true;
    
    clearPlayheads();
  }
  
  function scheduleNotes(){
    if(!isPlaying || !ctx) return;
    
    // Check if bars 3-4 are empty (for 2-bar loop)
    const sound = soundSelectEl.value;
    let bars34Empty = true;
    for(let ni = 0; ni < 7; ni++){
      for(let s = 32; s < 64; s++){
        if(melodyGridState[ni][s] !== null) bars34Empty = false;
      }
    }
    // Also check lanes
    Object.keys(lanes).forEach(snd => {
      if(lanes[snd].notes){
        for(let ni = 0; ni < 7; ni++){
          for(let s = 32; s < 64; s++){
            if(lanes[snd].notes[ni][s] !== null) bars34Empty = false;
          }
        }
      }
    });
    const melodyLoopLen = bars34Empty ? 32 : 64;
    
    while(nextStepTime < ctx.currentTime + scheduleAhead){
      const drumStep = currentStep % 16;
      const melodyStep = currentStep % melodyLoopLen;
      
      // Schedule drums
      drumTracks.forEach(track => {
        if(track.pattern[drumStep] && !track.muted && track.buffer && !drumMuted){
          playBuffer(track.buffer, nextStepTime, drumGain);
          
          // Sidechain trigger - only on kick
          if(track.key === "kick"){
            triggerSidechain(nextStepTime);
          }
        }
      });
      
      // Preview melody from current grid (only if lane for this sound is empty)
      const currentSound = soundSelectEl.value;
      const currentLane = lanes[currentSound];
      
      // Only play grid preview if no notes saved in lane for this sound
      if(!currentLane.notes){
        for(let ni = 0; ni < 7; ni++){
          const oct = melodyGridState[ni][melodyStep];
          if(oct !== null){
            const note = notes[ni];
            const freq = noteFreqs[note] * Math.pow(2, oct);
            const dur = stepDuration() * 0.9;
            
            switch(currentSound){
              case "bass": playBass(freq, nextStepTime, dur); break;
              case "lead": playLead(freq, nextStepTime, dur); break;
              case "pad": 
                const padDur = findNextPadNoteDuration(melodyGridState, melodyStep, melodyLoopLen, stepDuration());
                playPad(freq, nextStepTime, padDur);
                break;
              case "piano": playPiano(freq, nextStepTime, dur); break;
            }
            // For monophonic sounds, only play first note
            if(currentSound === "bass" || currentSound === "lead" || currentSound === "pad") break;
          }
        }
      }
      
      // Schedule melody from lanes (skip current sound if grid has unsaved notes)
      Object.keys(lanes).forEach(sound => {
        const lane = lanes[sound];
        if(!lane.notes || lane.muted) return;
        
        const laneEl = lanesEl.querySelector(`[data-sound="${sound}"]`);
        const vol = laneEl ? +laneEl.querySelector(".laneVol").value : 0.8;
        
        // For pad, only play first note found (monophonic legato)
        if(sound === "pad"){
          for(let ni = 0; ni < 7; ni++){
            const oct = lane.notes[ni][melodyStep];
            if(oct !== null){
              const note = notes[ni];
              const freq = noteFreqs[note] * Math.pow(2, oct);
              const padDur = findNextPadNoteDuration(lane.notes, melodyStep, melodyLoopLen, stepDuration());
              playPad(freq, nextStepTime, padDur);
              break; // Only play first note
            }
          }
        } else {
          for(let ni = 0; ni < 7; ni++){
            const oct = lane.notes[ni][melodyStep];
            if(oct !== null){
              const note = notes[ni];
              const freq = noteFreqs[note] * Math.pow(2, oct);
              const dur = stepDuration() * 0.9;
              
              switch(sound){
                case "bass": playBass(freq, nextStepTime, dur); break;
                case "lead": playLead(freq, nextStepTime, dur); break;
                case "piano": playPiano(freq, nextStepTime, dur); break;
              }
            }
          }
        }
      });
      
      // Update playhead
      setTimeout(() => updatePlayheads(drumStep, melodyStep), (nextStepTime - ctx.currentTime) * 1000);
      
      nextStepTime += stepDuration();
      currentStep++;
    }
  }
  
  function triggerSidechain(time){
    const duckAmount = 0.4;
    const attack = 0.01;  // Slightly longer attack to avoid click
    const release = 0.2;
    
    [bassGain, leadGain, padGain, pianoGain].forEach(g => {
      if(!g) return;
      g.gain.cancelScheduledValues(time);
      g.gain.setValueAtTime(g.gain.value, time);
      g.gain.linearRampToValueAtTime(duckAmount, time + attack);
      g.gain.linearRampToValueAtTime(0.8, time + release);
    });
  }
  
  function updatePlayheads(drumStep, melodyStep){
    // Drum playhead
    drumCells.forEach(cells => {
      cells.forEach((c, i) => c.classList.toggle("playhead", i === drumStep));
    });
    
    // Melody playhead
    const visibleStep = melodyStep - (currentBarView * 32);
    if(visibleStep >= 0 && visibleStep < 32){
      melodyCells.forEach(row => {
        row.forEach((c, i) => c.classList.toggle("playhead", i === visibleStep));
      });
    } else {
      // Clear playheads if not in current view
      melodyCells.forEach(row => {
        row.forEach(c => c.classList.remove("playhead"));
      });
    }
  }
  
  function clearPlayheads(){
    drumCells.forEach(cells => cells.forEach(c => c.classList.remove("playhead")));
    melodyCells.forEach(row => row.forEach(c => c.classList.remove("playhead")));
  }
  
  // ===== LOOP RECORDING =====
  const loopSlots = [null, null, null, null];
  const loopBtns = document.querySelectorAll(".loopBtn");
  const loopStatuses = document.querySelectorAll(".loopStatus");
  const loopStopBtn = document.getElementById("loopStopBtn");
  
  let armedSlot = -1;
  let recordingSlot = -1;
  let playingLoop = -1;
  let loopStep = 0;
  let loopScheduler = null;
  
  loopBtns.forEach((btn, i) => {
    btn.onclick = async () => {
      await initAudio();
      
      if(playingLoop === i){
        // Stop this loop
        stopLoopPlayback();
      } else if(loopSlots[i]){
        // Play this loop
        startLoopPlayback(i);
      } else if(armedSlot === i){
        // Disarm
        armedSlot = -1;
        updateLoopUI();
      } else {
        // Arm for recording
        armedSlot = i;
        updateLoopUI();
        
        // If playing, start recording on next bar
        if(isPlaying){
          recordingSlot = i;
          loopSlots[i] = captureCurrentState();
          armedSlot = -1;
          updateLoopUI();
        }
      }
    };
  });
  
  loopStopBtn.onclick = () => {
    stopLoopPlayback();
  };
  
  function captureCurrentState(){
    return {
      drums: drumTracks.map(t => ({ key: t.key, pattern: [...t.pattern], muted: t.muted })),
      bass: lanes.bass.notes ? lanes.bass.notes.map(r => [...r]) : null,
      lead: lanes.lead.notes ? lanes.lead.notes.map(r => [...r]) : null,
      pad: lanes.pad.notes ? lanes.pad.notes.map(r => [...r]) : null,
      piano: lanes.piano.notes ? lanes.piano.notes.map(r => [...r]) : null,
      tempo: tempo()
    };
  }
  
  function startLoopPlayback(slotIdx){
    stopPlayback();
    stopLoopPlayback();
    
    playingLoop = slotIdx;
    const slot = loopSlots[slotIdx];
    if(!slot) return;
    
    loopStep = 0;
    nextStepTime = ctx.currentTime + 0.05;
    
    loopScheduler = setInterval(() => {
      if(playingLoop < 0) return;
      
      // Check if bars 3-4 are empty for 2-bar loop
      let bars34Empty = true;
      ["bass", "lead", "pad", "piano"].forEach(sound => {
        const notes_data = slot[sound];
        if(notes_data){
          for(let ni = 0; ni < 7; ni++){
            for(let s = 32; s < 64; s++){
              if(notes_data[ni][s] !== null) bars34Empty = false;
            }
          }
        }
      });
      const loopLen = bars34Empty ? 32 : 64;
      
      while(nextStepTime < ctx.currentTime + scheduleAhead){
        const drumStep = loopStep % 16;
        const melodyStep = loopStep % loopLen;
        
        // Play drums from slot
        slot.drums.forEach(t => {
          const track = drumTracks.find(tr => tr.key === t.key);
          if(t.pattern[drumStep] && !t.muted && track?.buffer && !drumMuted){
            playBuffer(track.buffer, nextStepTime, drumGain);
            // Sidechain only on kick
            if(t.key === "kick"){
              triggerSidechain(nextStepTime);
            }
          }
        });
        
        // Play melodies from slot
        ["bass", "lead", "pad", "piano"].forEach(sound => {
          const notes_data = slot[sound];
          if(!notes_data) return;
          
          // For pad, only play first note (monophonic)
          if(sound === "pad"){
            for(let ni = 0; ni < 7; ni++){
              const oct = notes_data[ni][melodyStep];
              if(oct !== null){
                const note = notes[ni];
                const freq = noteFreqs[note] * Math.pow(2, oct);
                const loopStepDur = 60 / slot.tempo / 4;
                const padDur = findNextPadNoteDuration(notes_data, melodyStep, loopLen, loopStepDur);
                playPad(freq, nextStepTime, padDur);
                break; // Only first note
              }
            }
          } else {
            for(let ni = 0; ni < 7; ni++){
              const oct = notes_data[ni][melodyStep];
              if(oct !== null){
                const note = notes[ni];
                const freq = noteFreqs[note] * Math.pow(2, oct);
                const dur = 60 / slot.tempo / 4 * 0.9;
                
                switch(sound){
                  case "bass": playBass(freq, nextStepTime, dur); break;
                  case "lead": playLead(freq, nextStepTime, dur); break;
                  case "piano": playPiano(freq, nextStepTime, dur); break;
                }
                // Bass/Lead are monophonic
                if(sound === "bass" || sound === "lead") break;
              }
            }
          }
        });
        
        nextStepTime += 60 / slot.tempo / 4;
        loopStep++;
        if(loopStep >= loopLen) loopStep = 0;
      }
    }, 25);
    
    updateLoopUI();
  }
  
  function stopLoopPlayback(){
    playingLoop = -1;
    if(loopScheduler){
      clearInterval(loopScheduler);
      loopScheduler = null;
    }
    stopPad();
    updateLoopUI();
  }
  
  function updateLoopUI(){
    loopBtns.forEach((btn, i) => {
      btn.classList.remove("armed", "recording", "ready", "playing");
      
      if(playingLoop === i) btn.classList.add("playing");
      else if(recordingSlot === i) btn.classList.add("recording");
      else if(armedSlot === i) btn.classList.add("armed");
      else if(loopSlots[i]) btn.classList.add("ready");
      
      loopStatuses[i].textContent = loopSlots[i] ? "Ready" : "Empty";
    });
  }
  
  // ===== SAVE / LOAD =====
  const saveBtn = document.getElementById("saveBtn");
  const loadBtn = document.getElementById("loadBtn");
  const loadFileInput = document.getElementById("loadFileInput");
  const clearDrumBtn = document.getElementById("clearDrumBtn");
  
  saveBtn.onclick = () => {
    const state = {
      tempo: tempo(),
      masterVol: +masterVolEl.value,
      drums: drumTracks.map(t => ({ key: t.key, pattern: [...t.pattern], muted: t.muted })),
      lanes: {
        bass: lanes.bass.notes,
        lead: lanes.lead.notes,
        pad: lanes.pad.notes,
        piano: lanes.piano.notes
      },
      loopSlots: loopSlots
    };
    
    const blob = new Blob([JSON.stringify(state)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "music-maker.json";
    a.click();
    URL.revokeObjectURL(url);
  };
  
  loadBtn.onclick = () => loadFileInput.click();
  
  loadFileInput.onchange = async (e) => {
    const file = e.target.files[0];
    if(!file) return;
    
    try {
      const text = await file.text();
      const state = JSON.parse(text);
      
      if(state.tempo) tempoEl.value = state.tempo;
      tempoValEl.textContent = tempo();
      
      if(state.masterVol) masterVolEl.value = state.masterVol;
      
      if(state.drums){
        state.drums.forEach(saved => {
          const track = drumTracks.find(t => t.key === saved.key);
          if(track){
            track.pattern = saved.pattern;
            track.muted = saved.muted;
          }
        });
        buildDrumGrid();
      }
      
      if(state.lanes){
        lanes.bass.notes = state.lanes.bass;
        lanes.lead.notes = state.lanes.lead;
        lanes.pad.notes = state.lanes.pad;
        lanes.piano.notes = state.lanes.piano;
        updateLaneUI();
      }
      
      if(state.loopSlots){
        for(let i = 0; i < 4; i++){
          loopSlots[i] = state.loopSlots[i];
        }
        updateLoopUI();
      }
      
    } catch(e){
      console.error(e);
      alert("Failed to load file");
    }
    
    loadFileInput.value = "";
  };
  
  clearDrumBtn.onclick = () => {
    drumTracks.forEach(t => t.pattern.fill(false));
    buildDrumGrid();
  };
  
  // ===== HUB =====
  const hubBtn = document.getElementById("hubBtn");
  const hubModal = document.getElementById("hubModal");
  const hubClose = document.getElementById("hubClose");
  
  hubBtn.onclick = () => hubModal.classList.add("open");
  hubClose.onclick = () => hubModal.classList.remove("open");
  
  // ===== SPACEBAR =====
  document.addEventListener("keydown", async (e) => {
    if(e.code === "Space" && e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA"){
      e.preventDefault();
      if(isPlaying){
        stopPlayback();
      } else {
        await initAudio();
        await loadDrumSounds();
        createSynthGains();
        startPlayback();
      }
    }
  });
  
  // ===== INIT =====
  buildDrumGrid();
  buildMelodyGrid();
  updateLaneUI();
  updateLoopUI();
  
})();
</script>
</body>
</html>
